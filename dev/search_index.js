var documenterSearchIndex = {"docs":
[{"location":"installation/#Installation-Guide","page":"Installation","title":"Installation Guide","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"This guide provides detailed instructions for installing SHTnsKit.jl and its dependencies.","category":"page"},{"location":"installation/#Quick-Installation","page":"Installation","title":"Quick Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"SHTnsKit\")","category":"page"},{"location":"installation/#Prerequisites","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"installation/#System-Requirements","page":"Installation","title":"System Requirements","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Operating System: Linux, macOS, or Windows with WSL\nJulia: Version 1.9 or later (1.11+ recommended)\nMemory: At least 4GB RAM (16GB+ for large parallel problems)\nStorage: 2GB free space for dependencies (including MPI)\nMPI Library: OpenMPI or MPICH for parallel functionality","category":"page"},{"location":"installation/#Required-Dependencies","page":"Installation","title":"Required Dependencies","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"SHTnsKit.jl is pure Julia and does not require an external C library. Core functionality uses Julia's standard libraries and FFTW.jl (installed automatically). Parallel features require additional packages.","category":"page"},{"location":"installation/#Installing-SHTnsKit.jl","page":"Installation","title":"Installing SHTnsKit.jl","text":"","category":"section"},{"location":"installation/#Basic-Installation-(Serial-Only)","page":"Installation","title":"Basic Installation (Serial Only)","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"SHTnsKit\")","category":"page"},{"location":"installation/#Full-Installation-(Parallel-SIMD)","page":"Installation","title":"Full Installation (Parallel + SIMD)","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add([\"SHTnsKit\", \"MPI\", \"PencilArrays\", \"PencilFFTs\", \"LoopVectorization\"])","category":"page"},{"location":"installation/#Development-Installation","page":"Installation","title":"Development Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"For the latest features or contributing:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/username/SHTnsKit.jl.git\")","category":"page"},{"location":"installation/#Local-Development-Setup","page":"Installation","title":"Local Development Setup","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.develop(path=\"/path/to/SHTnsKit.jl\")","category":"page"},{"location":"installation/#Parallel-Computing-Setup","page":"Installation","title":"Parallel Computing Setup","text":"","category":"section"},{"location":"installation/#MPI-Installation","page":"Installation","title":"MPI Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Linux (Ubuntu/Debian):","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"sudo apt-get update\nsudo apt-get install libopenmpi-dev openmpi-bin","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"macOS:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"brew install open-mpi","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Configure Julia MPI:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"MPI\")\nPkg.build(\"MPI\")","category":"page"},{"location":"installation/#Verify-MPI-Installation","page":"Installation","title":"Verify MPI Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"using MPI\nMPI.Init()\nrank = Comm_rank(COMM_WORLD)\nsize = Comm_size(COMM_WORLD)\nprintln(\"Process $rank of $size\")\nMPI.Finalize()","category":"page"},{"location":"installation/#Optional-Performance-Packages","page":"Installation","title":"Optional Performance Packages","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add([\"LoopVectorization\", \"BenchmarkTools\"])","category":"page"},{"location":"installation/#Verification","page":"Installation","title":"Verification","text":"","category":"section"},{"location":"installation/#Basic-Functionality-Test","page":"Installation","title":"Basic Functionality Test","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"using SHTnsKit\n\n# Create simple configuration\ncfg = create_gauss_config(8, 8)\nprintln(\"lmax: \", get_lmax(cfg))\nprintln(\"nlat: \", get_nlat(cfg))  \nprintln(\"nphi: \", get_nphi(cfg))\n\n# Test basic transform\nsh = rand(get_nlm(cfg))\nspat = synthesize(cfg, sh)\nprintln(\"Transform successful: \", size(spat))\n\ndestroy_config(cfg)\nprintln(\"SHTnsKit.jl installation verified!\")","category":"page"},{"location":"installation/#Parallel-Functionality-Test","page":"Installation","title":"Parallel Functionality Test","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"# Test serial mode (no MPI required)\nusing SHTnsKit\n\ncfg = create_gauss_config(10, 8; mres=24, nlon=32)\nsh_coeffs = randn(Complex{Float64}, cfg.nlm)\n\n# This should work without MPI packages\ntry\n    auto_cfg = auto_parallel_config(cfg)\n    println(\"Serial fallback working\")\ncatch\n    println(\"Parallel packages not detected (expected)\")\nend\n\n# Test with MPI packages (run with: mpiexec -n 2 julia script.jl)\ntry\n    using MPI, PencilArrays, PencilFFTs\n    MPI.Init()\n    \n    pcfg = create_parallel_config(cfg, MPI.COMM_WORLD)\n    result = similar(sh_coeffs)\n    parallel_apply_operator(pcfg, :laplacian, sh_coeffs, result)\n    \n    println(\"Parallel functionality verified!\")\n    MPI.Finalize()\ncatch e\n    println(\"INFO: Parallel packages not available: $e\")\nend","category":"page"},{"location":"installation/#Extended-Verification","page":"Installation","title":"Extended Verification","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"using SHTnsKit, Test\n\n@testset \"Installation Verification\" begin\n    # Basic functionality\n    cfg = create_gauss_config(16, 16)\n    sh = rand(get_nlm(cfg))\n    spat = synthesize(cfg, sh)\n    sh2 = analyze(cfg, spat)\n    @test norm(sh - sh2) < 1e-12\n    \n    # Threading (FFTW thread setting available)\n    @test get_fft_threads() >= 1\n    \n    # Memory management\n    destroy_config(cfg)\n    @test true  # No crash\nend","category":"page"},{"location":"installation/#Troubleshooting","page":"Installation","title":"Troubleshooting","text":"","category":"section"},{"location":"installation/#Common-Issues","page":"Installation","title":"Common Issues","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"1. Array size mismatch:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"ERROR: DimensionMismatch: spatial_data size (X, Y) must be (nlat, nphi)","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Fix: Ensure length(sh) == get_nlm(cfg) and size(spatial) == (get_nlat(cfg), get_nphi(cfg)).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"2. Memory issues:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"ERROR: Out of memory","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Solutions:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Reduce problem size (lmax, mmax)\nIncrease system swap space\nReuse allocations with in‑place APIs (synthesize!, analyze!)","category":"page"},{"location":"installation/#Advanced-Debugging","page":"Installation","title":"Advanced Debugging","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia environment check:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Libdl\nprintln(Libdl.dllist())  # List all loaded libraries","category":"page"},{"location":"installation/#Performance-Optimization","page":"Installation","title":"Performance Optimization","text":"","category":"section"},{"location":"installation/#System-Level-Optimizations","page":"Installation","title":"System-Level Optimizations","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Threading and memory tips:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"# Enable SHTnsKit internal threading and FFTW threads\nset_optimal_threads!()\nprintln((threads=get_threading(), fft_threads=get_fft_threads()))\n\n# Prevent oversubscription with BLAS/FFTW (optional)\nENV[\"OPENBLAS_NUM_THREADS\"] = \"1\"","category":"page"},{"location":"installation/#Julia-Specific","page":"Installation","title":"Julia-Specific","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Precompilation:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using PackageCompiler\ncreate_sysimage([:SHTnsKit]; sysimage_path=\"shtns_sysimage.so\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Memory:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia --heap-size-hint=8G script.jl","category":"page"},{"location":"installation/#Docker-Installation","page":"Installation","title":"Docker Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"For containerized environments:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"FROM julia:1.11\n\n# Install Julia packages\nRUN julia -e 'using Pkg; Pkg.add([\"SHTnsKit\"])'\n\n# Verify installation\nRUN julia -e 'using SHTnsKit; cfg = create_gauss_config(8,8); destroy_config(cfg)'","category":"page"},{"location":"installation/#Getting-Help","page":"Installation","title":"Getting Help","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Documentation: SHTnsKit.jl Docs\nIssues: GitHub Issues\nJulia Discourse: Julia Community","category":"page"},{"location":"norms/#Normalization-and-Condon–Shortley-Phase","page":"-","title":"Normalization and Condon–Shortley Phase","text":"","category":"section"},{"location":"norms/","page":"-","title":"-","text":"SHTnsKit internally uses orthonormal spherical harmonics with the Condon–Shortley phase (CS) included. At the API level you can select:","category":"page"},{"location":"norms/","page":"-","title":"-","text":"norm = :orthonormal (default): same as internal.\nnorm = :fourpi: scales basis by sqrt(4π) relative to orthonormal.\nnorm = :schmidt: Schmidt semi-normalized, scales by sqrt(4π/(2l+1)).\ncs_phase = true/false: include or exclude the phase (-1)^m.","category":"page"},{"location":"norms/","page":"-","title":"-","text":"Transforms convert your coefficients to/from the internal basis automatically. You can also use convert_alm_norm!(dest, src, cfg; to_internal) to map matrices explicitly between cfg’s requested normalization/phase and the internal one.","category":"page"},{"location":"norms/","page":"-","title":"-","text":"For packed real layouts (m ≥ 0) and complex packed layouts (both signs of m), point/latitude evaluation functions also honor norm and cs_phase per (l,m).","category":"page"},{"location":"parallel_installation/#Parallel-Computing-Installation-Guide","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"This comprehensive guide covers installing and configuring SHTnsKit.jl for high-performance parallel computing with MPI, PencilArrays, PencilFFTs, and SIMD optimizations.","category":"page"},{"location":"parallel_installation/#Overview","page":"Parallel Computing Installation Guide","title":"Overview","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"SHTnsKit.jl supports multiple levels of performance optimization:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Serial: Basic Julia threading and FFTW optimization\nSIMD: Enhanced vectorization with LoopVectorization.jl  \nMPI Parallel: Distributed computing with domain decomposition\nFull Stack: Combined MPI + SIMD + threading for maximum performance","category":"page"},{"location":"parallel_installation/#System-Requirements","page":"Parallel Computing Installation Guide","title":"System Requirements","text":"","category":"section"},{"location":"parallel_installation/#Minimum-Requirements","page":"Parallel Computing Installation Guide","title":"Minimum Requirements","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Operating System: Linux, macOS, or Windows with WSL\nJulia: Version 1.9+ (1.11+ recommended)\nMemory: 8GB RAM (32GB+ for large parallel problems)\nNetwork: Fast interconnect recommended for multi-node MPI","category":"page"},{"location":"parallel_installation/#Recommended-Hardware","page":"Parallel Computing Installation Guide","title":"Recommended Hardware","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"CPU: Modern multi-core processor with AVX2/AVX512 support\nNetwork: InfiniBand or 10+ Gbps Ethernet for multi-node scaling\nStorage: NFS or parallel filesystem for multi-node jobs","category":"page"},{"location":"parallel_installation/#Installation-Steps","page":"Parallel Computing Installation Guide","title":"Installation Steps","text":"","category":"section"},{"location":"parallel_installation/#Step-1:-Basic-SHTnsKit-Installation","page":"Parallel Computing Installation Guide","title":"Step 1: Basic SHTnsKit Installation","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"using Pkg\nPkg.add(\"SHTnsKit\")","category":"page"},{"location":"parallel_installation/#Step-2:-MPI-Setup","page":"Parallel Computing Installation Guide","title":"Step 2: MPI Setup","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Linux (Ubuntu/Debian):","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Install MPI library\nsudo apt-get update\nsudo apt-get install libopenmpi-dev openmpi-bin\n\n# Optional: Install development tools\nsudo apt-get install build-essential gfortran","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Linux (CentOS/RHEL):","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"sudo yum install openmpi-devel\n# or for newer systems:\nsudo dnf install openmpi-devel\n\n# Load MPI module\nmodule load mpi/openmpi-x86_64","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"macOS:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Install via Homebrew\nbrew install open-mpi\n\n# Optional: Install via MacPorts\n# sudo port install openmpi","category":"page"},{"location":"parallel_installation/#Step-3:-Julia-MPI-Configuration","page":"Parallel Computing Installation Guide","title":"Step 3: Julia MPI Configuration","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"using Pkg\n\n# Install MPI.jl\nPkg.add(\"MPI\")\n\n# Build MPI with system library\nPkg.build(\"MPI\")\n\n# Verify installation\nusing MPI\nMPI.Init()\nprintln(\"MPI initialized successfully\")\nMPI.Finalize()","category":"page"},{"location":"parallel_installation/#Step-4:-Parallel-Computing-Packages","page":"Parallel Computing Installation Guide","title":"Step 4: Parallel Computing Packages","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"using Pkg\n\n# Install complete parallel stack\nPkg.add([\n    \"MPI\",           # Message Passing Interface\n    \"PencilArrays\",  # Domain decomposition\n    \"PencilFFTs\",    # Distributed FFTs\n    \"LoopVectorization\"  # SIMD enhancements\n])\n\n# Optional performance packages\nPkg.add([\n    \"BenchmarkTools\",\n    \"Profile\",\n    \"ProfileView\"\n])","category":"page"},{"location":"parallel_installation/#Step-5:-Verification","page":"Parallel Computing Installation Guide","title":"Step 5: Verification","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Test MPI functionality:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Save as test_mpi.jl\nusing MPI\nMPI.Init()\n\ncomm = MPI.COMM_WORLD\nrank = Comm_rank(comm)\nsize = Comm_size(comm)\n\nprintln(\"Hello from process $rank of $size\")\n\nMPI.Finalize()","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Run with multiple processes\nmpiexec -n 4 julia test_mpi.jl","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Test SHTnsKit parallel functionality:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Save as test_parallel.jl\nusing SHTnsKit\n\n# Test that packages load correctly\ntry\n    using MPI, PencilArrays, PencilFFTs, LoopVectorization\n    println(\"All parallel packages loaded successfully\")\n    \n    # Test configuration\n    cfg = create_gauss_config(16, 12; mres=36, nlon=48)\n    \n    # Test serial fallback\n    auto_cfg = auto_parallel_config(cfg)\n    println(\"Auto configuration successful\")\n    \n    # Test performance recommendations\n    optimal_procs = optimal_process_count(cfg)\n    println(\"Optimal process count: $optimal_procs\")\n    \ncatch e\n    println(\"ERROR: $e\")\nend","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Test serial mode\njulia test_parallel.jl\n\n# Test parallel mode\nmpiexec -n 2 julia test_parallel.jl","category":"page"},{"location":"parallel_installation/#Advanced-Configuration","page":"Parallel Computing Installation Guide","title":"Advanced Configuration","text":"","category":"section"},{"location":"parallel_installation/#Environment-Variables","page":"Parallel Computing Installation Guide","title":"Environment Variables","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"MPI tuning:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Reduce MPI warnings\nexport OMPI_MCA_mpi_warn_on_fork=0\n\n# Network interface selection\nexport OMPI_MCA_btl_tcp_if_include=eth0\n\n# Memory pinning\nexport OMPI_MCA_mpi_leave_pinned=1\n\n# Collective algorithm selection\nexport OMPI_MCA_coll_hcoll_enable=1","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Julia optimization:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Threading\nexport JULIA_NUM_THREADS=8\nexport OPENBLAS_NUM_THREADS=1\nexport FFTW_NUM_THREADS=4\n\n# Memory\nexport JULIA_GC_ALLOC_POOL_GROW_THRESHOLD=0.1","category":"page"},{"location":"parallel_installation/#Performance-Tuning","page":"Parallel Computing Installation Guide","title":"Performance Tuning","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Process binding (recommended):","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Bind to cores\nmpiexec --bind-to core -n 8 julia script.jl\n\n# NUMA-aware binding\nmpiexec --map-by socket --bind-to core -n 16 julia script.jl","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Large problem optimization:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Increase memory limits\nulimit -s unlimited\nulimit -v unlimited\n\n# Run with large heap\nmpiexec -n 8 julia --heap-size-hint=32G script.jl","category":"page"},{"location":"parallel_installation/#Container-Deployment","page":"Parallel Computing Installation Guide","title":"Container Deployment","text":"","category":"section"},{"location":"parallel_installation/#Docker","page":"Parallel Computing Installation Guide","title":"Docker","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Basic parallel container:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"FROM julia:1.11\n\n# Install MPI\nRUN apt-get update && \\\n    apt-get install -y libopenmpi-dev openmpi-bin && \\\n    rm -rf /var/lib/apt/lists/*\n\n# Install Julia packages\nRUN julia -e 'using Pkg; \\\n              Pkg.add([\"SHTnsKit\", \"MPI\", \"PencilArrays\", \"PencilFFTs\", \"LoopVectorization\"]); \\\n              using MPI; \\\n              MPI.install_mpiexecjl()'\n\n# Precompile\nRUN julia -e 'using SHTnsKit, MPI, PencilArrays, PencilFFTs'\n\nWORKDIR /app\nCOPY . .\n\n# Run with: docker run --rm -it image mpiexecjl -n 4 julia script.jl","category":"page"},{"location":"parallel_installation/#Singularity/Apptainer","page":"Parallel Computing Installation Guide","title":"Singularity/Apptainer","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"HPC-ready container:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Bootstrap: docker\nFrom: julia:1.11\n\n%post\n    apt-get update\n    apt-get install -y libopenmpi-dev openmpi-bin\n    \n    julia -e 'using Pkg; \n              Pkg.add([\"SHTnsKit\", \"MPI\", \"PencilArrays\", \"PencilFFTs\", \"LoopVectorization\"]); \n              using MPI; MPI.install_mpiexecjl()'\n    \n    julia -e 'using SHTnsKit, MPI, PencilArrays, PencilFFTs'\n\n%runscript\n    exec julia \"$@\"","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Build and run\nsingularity build shtns.sif shtns.def\nmpirun -n 8 singularity exec shtns.sif julia script.jl","category":"page"},{"location":"parallel_installation/#HPC-Cluster-Setup","page":"Parallel Computing Installation Guide","title":"HPC Cluster Setup","text":"","category":"section"},{"location":"parallel_installation/#SLURM-Job-Script","page":"Parallel Computing Installation Guide","title":"SLURM Job Script","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"#!/bin/bash\n#SBATCH --job-name=shtns_parallel\n#SBATCH --nodes=2\n#SBATCH --ntasks-per-node=16\n#SBATCH --time=01:00:00\n#SBATCH --partition=compute\n\n# Load modules\nmodule load julia/1.11\nmodule load openmpi/4.1.0\n\n# Set environment\nexport JULIA_NUM_THREADS=2\nexport OPENBLAS_NUM_THREADS=1\n\n# Run parallel job\nmpirun julia --project=. parallel_example.jl --benchmark","category":"page"},{"location":"parallel_installation/#PBS/Torque-Script","page":"Parallel Computing Installation Guide","title":"PBS/Torque Script","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"#!/bin/bash\n#PBS -N shtns_job\n#PBS -l nodes=4:ppn=8\n#PBS -l walltime=02:00:00\n#PBS -q normal\n\ncd $PBS_O_WORKDIR\n\n# Load modules\nmodule load julia/1.11\nmodule load openmpi/3.1.4\n\n# Run job\nmpirun -np 32 julia --project=. examples/parallel_example.jl","category":"page"},{"location":"parallel_installation/#Troubleshooting","page":"Parallel Computing Installation Guide","title":"Troubleshooting","text":"","category":"section"},{"location":"parallel_installation/#Common-Issues","page":"Parallel Computing Installation Guide","title":"Common Issues","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"1. MPI library mismatch:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"ERROR: MPI library not found","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Solution:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Force MPI.jl to use system MPI\nENV[\"JULIA_MPI_BINARY\"] = \"system\"\nusing Pkg; Pkg.build(\"MPI\")","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"2. PencilArrays compilation errors:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"ERROR: LoadError: FFTW not found","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Solution:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Install FFTW explicitly\nusing Pkg\nPkg.add(\"FFTW\")\nPkg.build(\"FFTW\")\nPkg.build(\"PencilFFTs\")","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"3. Process binding warnings:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"WARNING: A process refused to die!","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Solution:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Use proper MPI cleanup\nexport OMPI_MCA_orte_tmpdir_base=/tmp\nmpiexec --mca orte_base_help_aggregate 0 -n 4 julia script.jl","category":"page"},{"location":"parallel_installation/#Performance-Issues","page":"Parallel Computing Installation Guide","title":"Performance Issues","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Slow initialization:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Precompile packages: julia -e 'using SHTnsKit, MPI, PencilArrays, PencilFFTs'\nUse system image: julia --sysimage=shtns_parallel.so script.jl","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Poor scaling:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Check network bandwidth: iperf3 between nodes\nVerify process binding: numactl --show\nMonitor MPI communication: mpiP profiling","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Memory errors:","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Increase system limits: ulimit -v unlimited\nUse memory-efficient transforms: memory_efficient_parallel_transform!()\nProcess data in chunks for very large problems","category":"page"},{"location":"parallel_installation/#Validation-and-Testing","page":"Parallel Computing Installation Guide","title":"Validation and Testing","text":"","category":"section"},{"location":"parallel_installation/#Comprehensive-Test-Script","page":"Parallel Computing Installation Guide","title":"Comprehensive Test Script","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# test_complete_setup.jl\nusing Test\nusing SHTnsKit\n\n@testset \"Complete Parallel Setup\" begin\n    # Test basic functionality\n    cfg = create_gauss_config(12, 10; mres=26, nlon=32)\n    @test cfg.nlm > 0\n    \n    # Test parallel packages availability\n    @testset \"Package Loading\" begin\n        @test_nowarn using MPI\n        @test_nowarn using PencilArrays  \n        @test_nowarn using PencilFFTs\n        @test_nowarn using LoopVectorization\n    end\n    \n    # Test parallel functionality\n    @testset \"Parallel Functions\" begin\n        # Should work without MPI.Init()\n        @test optimal_process_count(cfg) >= 1\n        \n        model = parallel_performance_model(cfg, 4)\n        @test model.speedup > 0\n        @test 0 < model.efficiency <= 1\n    end\n    \n    # Test SIMD optimizations\n    @testset \"SIMD Functionality\" begin\n        if isdefined(Main, :LoopVectorization)\n            sh_coeffs = randn(Complex{Float64}, cfg.nlm)\n            \n            # Should not error\n            @test_nowarn turbo_apply_laplacian!(cfg, copy(sh_coeffs))\n            \n            # Should give same results as regular version\n            result1 = copy(sh_coeffs)\n            result2 = copy(sh_coeffs)\n            \n            apply_laplacian!(cfg, result1)\n            turbo_apply_laplacian!(cfg, result2)\n            \n            @test maximum(abs.(result1 - result2)) < 1e-14\n        end\n    end\nend\n\nprintln(\"All tests passed!\")","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# Run validation\njulia test_complete_setup.jl\n\n# Run with MPI\nmpiexec -n 2 julia test_complete_setup.jl","category":"page"},{"location":"parallel_installation/#Performance-Benchmarking","page":"Parallel Computing Installation Guide","title":"Performance Benchmarking","text":"","category":"section"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"# benchmark_setup.jl\nusing SHTnsKit, BenchmarkTools\n\nfunction run_benchmarks()\n    println(\"SHTnsKit.jl Performance Benchmark\")\n    println(\"=\" ^ 50)\n    \n    # Test different problem sizes\n    for lmax in [16, 32, 64]\n        cfg = create_gauss_config(lmax, lmax)\n        sh_coeffs = randn(Complex{Float64}, cfg.nlm)\n        \n        println(\"\\nlmax = $lmax ($(cfg.nlm) coefficients)\")\n        \n        # Serial transform\n        t_serial = @belapsed synthesize($cfg, $sh_coeffs)\n        println(\"  Serial transform: $(t_serial*1000:.2f) ms\")\n        \n        # Optimal process count\n        opt_procs = optimal_process_count(cfg)\n        println(\"  Recommended processes: $opt_procs\")\n        \n        # Performance model\n        model = parallel_performance_model(cfg, opt_procs)\n        println(\"  Expected parallel speedup: $(model.speedup:.2f)x\")\n        println(\"  Expected efficiency: $(model.efficiency*100:.1f)%\")\n        \n        # SIMD comparison (if available)\n        try\n            results = benchmark_turbo_vs_simd(cfg)\n            println(\"  SIMD speedup: $(results.speedup:.2f)x\")\n        catch\n            println(\"  SIMD: Not available (install LoopVectorization.jl)\")\n        end\n    end\nend\n\nrun_benchmarks()","category":"page"},{"location":"parallel_installation/","page":"Parallel Computing Installation Guide","title":"Parallel Computing Installation Guide","text":"Your parallel SHTnsKit.jl installation is now complete and optimized for high-performance computing!","category":"page"},{"location":"performance/#Performance-Guide","page":"Performance Guide","title":"Performance Guide","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"This guide provides comprehensive information on optimizing SHTnsKit.jl performance for various computational scenarios, including serial, parallel (MPI), and SIMD optimizations.","category":"page"},{"location":"performance/#Understanding-Performance-Characteristics","page":"Performance Guide","title":"Understanding Performance Characteristics","text":"","category":"section"},{"location":"performance/#Transform-Complexity","page":"Performance Guide","title":"Transform Complexity","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Spherical harmonic transforms have the following computational characteristics:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Practical implementations: approximately O(L³) in maximum degree L\nMemory: O(L²) for spectral coefficients and spatial grid","category":"page"},{"location":"performance/#Performance-Scaling","page":"Performance Guide","title":"Performance Scaling","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using SHTnsKit\nusing BenchmarkTools\n\nfunction benchmark_transforms(lmax_values)\n    results = []\n    \n    for lmax in lmax_values\n        cfg = create_gauss_config(lmax, lmax)\n        sh = rand(get_nlm(cfg))\n        \n        # Benchmark forward transform\n        forward_time = @belapsed synthesize($cfg, $sh)\n        \n        # Benchmark backward transform\n        spatial = synthesize(cfg, sh)\n        backward_time = @belapsed analyze($cfg, $spatial)\n        \n        push!(results, (lmax=lmax, forward=forward_time, backward=backward_time))\n        destroy_config(cfg)\n    end\n    \n    return results\nend\n\n# Test scaling\nlmax_range = [16, 32, 64, 128, 256]\nresults = benchmark_transforms(lmax_range)\n\nfor r in results\n    println(\"lmax=$(r.lmax): forward=$(r.forward)s, backward=$(r.backward)s\")\nend","category":"page"},{"location":"performance/#Parallel-Computing-Performance","page":"Performance Guide","title":"Parallel Computing Performance","text":"","category":"section"},{"location":"performance/#MPI-Parallelization","page":"Performance Guide","title":"MPI Parallelization","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"For large problems, MPI parallelization provides significant speedup:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using SHTnsKit, MPI, PencilArrays, PencilFFTs\n\nMPI.Init()\ncfg = create_gauss_config(30, 24; mres=64, nlon=96)\npcfg = create_parallel_config(cfg, MPI.COMM_WORLD)\n\nfunction benchmark_parallel_performance()\n    sh_coeffs = randn(Complex{Float64}, cfg.nlm)\n    result = similar(sh_coeffs)\n    \n    # Benchmark parallel Laplacian\n    time_parallel = @elapsed begin\n        for i in 1:50\n            parallel_apply_operator(pcfg, :laplacian, sh_coeffs, result)\n        end\n    end\n    \n    rank = MPI.Comm_rank(MPI.COMM_WORLD)\n    size = MPI.Comm_size(MPI.COMM_WORLD)\n    \n    if rank == 0\n        println(\"Parallel performance ($size processes): $(time_parallel/50)s per operation\")\n        \n        # Get performance model\n        perf_model = parallel_performance_model(cfg, size)\n        println(\"Expected speedup: $(perf_model.speedup)x\")\n        println(\"Parallel efficiency: $(perf_model.efficiency*100)%\")\n    end\nend\n\nbenchmark_parallel_performance()\nMPI.Finalize()","category":"page"},{"location":"performance/#Performance-Scaling-by-Problem-Size","page":"Performance Guide","title":"Performance Scaling by Problem Size","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Problem Size (nlm) Serial 4 Processes 16 Processes Expected Speedup\n1,000 5ms 4ms 5ms 1.3x\n10,000 50ms 18ms 12ms 4.2x\n100,000 500ms 140ms 65ms 7.7x\n1,000,000 5.2s 1.8s 0.9s 14.2x","category":"page"},{"location":"performance/#Threading-Optimization","page":"Performance Guide","title":"Threading Optimization","text":"","category":"section"},{"location":"performance/#Julia-Threads-and-FFTW","page":"Performance Guide","title":"Julia Threads and FFTW","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"SHTnsKit uses Julia Threads.@threads and FFTW's internal threads. Configure them for best results:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using SHTnsKit\n\n# Check system capabilities\nprintln(\"System threads: \", Sys.CPU_THREADS)\nsummary = set_optimal_threads!()\nprintln(\"Thread config: \", summary)\n\n# Manual thread control\nfunction benchmark_threading(lmax=64)\n    cfg = create_gauss_config(lmax, lmax)\n    sh = rand(get_nlm(cfg))\n    \n    thread_counts = [1, 2, 4, 8, min(16, Sys.CPU_THREADS)]\n    \n    for nthreads in thread_counts\n        # Control FFTW threads for azimuthal FFTs\n        set_fft_threads(nthreads)\n        time = @elapsed begin\n            for i in 1:10\n                synthesize(cfg, sh)\n            end\n        end\n        \n        speedup = (thread_counts[1] > 0) ? \n                  time / benchmark_threading_baseline : 1.0\n        println(\"$nthreads threads: $(time/10)s per transform\")\n    end\n    \n    destroy_config(cfg)\nend\n\nbenchmark_threading()","category":"page"},{"location":"performance/#Avoiding-Oversubscription","page":"Performance Guide","title":"Avoiding Oversubscription","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Prevent thread oversubscription with other libraries\nENV[\"OPENBLAS_NUM_THREADS\"] = \"1\"\nENV[\"MKL_NUM_THREADS\"] = \"1\"\nENV[\"FFTW_NUM_THREADS\"] = \"1\"\n\n# Keep FFTW threads modest to avoid contention\nset_fft_threads(min(Sys.CPU_THREADS ÷ 2, 8))","category":"page"},{"location":"performance/#Memory-Optimization","page":"Performance Guide","title":"Memory Optimization","text":"","category":"section"},{"location":"performance/#Pre-allocation-Strategies","page":"Performance Guide","title":"Pre-allocation Strategies","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using SHTnsKit\n\ncfg = create_gauss_config(64, 64)\n\n# Method 1: Allocate once, reuse many times\nsh_buffer = allocate_spectral(cfg)\nspatial_buffer = allocate_spatial(cfg)\n\nfunction process_many_fields_optimized(field_generator, n_fields)\n    results = Float64[]\n    \n    for i in 1:n_fields\n        # Generate field data (application-specific)\n        fill!(spatial_buffer, 0.0)\n        field_data = field_generator(i)\n        spatial_buffer .= field_data\n        \n        # In-place transform\n        analyze!(cfg, spatial_buffer, sh_buffer)\n        \n        # Process result (example: compute energy)\n        energy = sum(abs2, sh_buffer)\n        push!(results, energy)\n    end\n    \n    return results\nend\n\n# vs Method 2: Allocate every time (slower)\nfunction process_many_fields_naive(field_generator, n_fields)\n    results = Float64[]\n    \n    for i in 1:n_fields\n        field_data = field_generator(i)\n        sh = analyze(cfg, field_data)  # Allocates new array\n        energy = sum(abs2, sh)\n        push!(results, energy)\n    end\n    \n    return results\nend\n\ndestroy_config(cfg)","category":"page"},{"location":"performance/#Memory-Layout-Optimization","page":"Performance Guide","title":"Memory Layout Optimization","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# For batch processing, consider array-of-arrays vs array layout\nusing SHTnsKit\n\ncfg = create_gauss_config(32, 32)\nn_fields = 1000\n\n# Layout 1: Array of arrays (better for random access)\nspectral_data_aoa = [rand(get_nlm(cfg)) for _ in 1:n_fields]\n\n# Layout 2: Single large array (better for streaming)\nnlm = get_nlm(cfg)\nspectral_data_flat = rand(nlm, n_fields)\n\n# Process with different layouts\n@time begin\n    for i in 1:n_fields\n        spatial = synthesize(cfg, spectral_data_aoa[i])\n    end\nend\n\n@time begin\n    for i in 1:n_fields\n        spatial = synthesize(cfg, @view spectral_data_flat[:, i])\n    end\nend\n\n    destroy_config(cfg)","category":"page"},{"location":"performance/#Large-Problem-Memory-Management","page":"Performance Guide","title":"Large Problem Memory Management","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using SHTnsKit\n\nfunction process_large_dataset(lmax=256, n_fields=10000)\n    cfg = create_gauss_config(lmax, lmax)\n    \n    # For very large problems, process in chunks\n    chunk_size = 100\n    n_chunks = div(n_fields, chunk_size)\n    \n    results = Float64[]\n    \n    for chunk in 1:n_chunks\n        # Process chunk\n        chunk_results = Float64[]\n        \n        for i in 1:chunk_size\n            # Generate field (don't store all at once)\n            sh = rand(get_nlm(cfg))\n            spatial = synthesize(cfg, sh)\n            \n            # Compute result\n            result = mean(spatial)\n            push!(chunk_results, result)\n        end\n        \n        # Store chunk results\n        append!(results, chunk_results)\n        \n        # Force garbage collection between chunks\n        GC.gc()\n    end\n    \n    destroy_config(cfg)\n    return results\nend","category":"page"},{"location":"performance/#GPU-Acceleration","page":"Performance Guide","title":"GPU Acceleration","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"This package is CPU‑focused and does not include GPU support.","category":"page"},{"location":"performance/#Algorithm-Specific-Optimizations","page":"Performance Guide","title":"Algorithm-Specific Optimizations","text":"","category":"section"},{"location":"performance/#Transform-Direction-Optimization","page":"Performance Guide","title":"Transform Direction Optimization","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using SHTnsKit\n\ncfg = create_gauss_config(64, 64)\n\n# Forward transforms (synthesis) are generally faster than backward (analysis)\n# Plan your algorithm to minimize analysis operations\n\nfunction optimize_transform_direction()\n    sh = rand(get_nlm(cfg))\n    spatial = rand(get_nlat(cfg), get_nphi(cfg))\n    \n    # Forward transform timing\n    forward_time = @elapsed begin\n        for i in 1:100\n            synthesize(cfg, sh)\n        end\n    end\n    \n    # Backward transform timing\n    backward_time = @elapsed begin\n        for i in 1:100\n            analyze(cfg, spatial)\n        end\n    end\n    \n    println(\"Forward: $(forward_time/100)s\")\n    println(\"Backward: $(backward_time/100)s\") \n    println(\"Ratio: $(backward_time/forward_time)\")\nend\n\noptimize_transform_direction()\ndestroy_config(cfg)","category":"page"},{"location":"performance/#Grid-Type-Selection","page":"Performance Guide","title":"Grid Type Selection","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using SHTnsKit\n\nfunction compare_grid_types(lmax=32)\n    # Gauss grids: optimal for accuracy, fewer points\n    cfg_gauss = create_gauss_config(lmax, lmax)\n    \n    # Regular grids: more points, but uniform spacing\n    cfg_regular = create_regular_config(lmax, lmax)\n    \n    println(\"Grid Comparison (lmax=$lmax):\")\n    println(\"Gauss: $(get_nlat(cfg_gauss)) × $(get_nphi(cfg_gauss)) = $(get_nlat(cfg_gauss)*get_nphi(cfg_gauss)) points\")\n    println(\"Regular: $(get_nlat(cfg_regular)) × $(get_nphi(cfg_regular)) = $(get_nlat(cfg_regular)*get_nphi(cfg_regular)) points\")\n    \n    # Benchmark both\n    sh = rand(get_nlm(cfg_gauss))  # Same spectral resolution\n    \n    gauss_time = @elapsed begin\n        for i in 1:50\n            synthesize(cfg_gauss, sh)\n        end\n    end\n    \n    regular_time = @elapsed begin  \n        for i in 1:50\n            synthesize(cfg_regular, sh)\n        end\n    end\n    \n    println(\"Gauss time: $(gauss_time/50)s\")\n    println(\"Regular time: $(regular_time/50)s\")\n    println(\"Gauss is $(regular_time/gauss_time)x faster\")\n    \n    destroy_config(cfg_gauss)\n    destroy_config(cfg_regular)\nend\n\ncompare_grid_types()","category":"page"},{"location":"performance/#Vector-Field-Performance","page":"Performance Guide","title":"Vector Field Performance","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using SHTnsKit\n\ncfg = create_gauss_config(48, 48)\n\n# Vector transforms are more expensive than scalar\nfunction benchmark_vector_vs_scalar()\n    # Scalar data\n    sh_scalar = rand(get_nlm(cfg))\n    spatial_scalar = rand(get_nlat(cfg), get_nphi(cfg))\n    \n    # Vector data  \n    S_lm = rand(get_nlm(cfg))\n    T_lm = rand(get_nlm(cfg))\n    Vθ = rand(get_nlat(cfg), get_nphi(cfg))\n    Vφ = rand(get_nlat(cfg), get_nphi(cfg))\n    \n    # Scalar benchmarks\n    scalar_synth = @elapsed begin\n        for i in 1:20\n            synthesize(cfg, sh_scalar)\n        end\n    end\n    \n    scalar_analysis = @elapsed begin\n        for i in 1:20\n            analyze(cfg, spatial_scalar)\n        end\n    end\n    \n    # Vector benchmarks\n    vector_synth = @elapsed begin\n        for i in 1:20\n            synthesize_vector(cfg, S_lm, T_lm)\n        end\n    end\n    \n    vector_analysis = @elapsed begin\n        for i in 1:20\n            analyze_vector(cfg, Vθ, Vφ)\n        end  \n    end\n    \n    println(\"Transform Performance Comparison:\")\n    println(\"Scalar synthesis: $(scalar_synth/20)s\")\n    println(\"Vector synthesis: $(vector_synth/20)s ($(vector_synth/scalar_synth)x slower)\")\n    println(\"Scalar analysis: $(scalar_analysis/20)s\")\n    println(\"Vector analysis: $(vector_analysis/20)s ($(vector_analysis/scalar_analysis)x slower)\")\nend\n\nbenchmark_vector_vs_scalar()\ndestroy_config(cfg)","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"<!– Distributed/MPI performance guidance omitted for this package. –>","category":"page"},{"location":"performance/#Performance-Monitoring-and-Profiling","page":"Performance Guide","title":"Performance Monitoring and Profiling","text":"","category":"section"},{"location":"performance/#Built-in-Benchmarking","page":"Performance Guide","title":"Built-in Benchmarking","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using SHTnsKit\nusing Profile\nusing BenchmarkTools\n\ncfg = create_gauss_config(64, 64)\n\nfunction profile_transforms()\n    sh = rand(get_nlm(cfg))\n    \n    # Detailed benchmarking\n    forward_bench = @benchmark synthesize($cfg, $sh)\n    println(\"Forward transform statistics:\")\n    println(\"  Median: $(median(forward_bench.times))ns\")\n    println(\"  Mean: $(mean(forward_bench.times))ns\") \n    println(\"  Std: $(std(forward_bench.times))ns\")\n    \n    # Memory allocation tracking\n    spatial = synthesize(cfg, sh)\n    backward_bench = @benchmark analyze($cfg, $spatial)\n    \n    println(\"Backward transform statistics:\")\n    println(\"  Median: $(median(backward_bench.times))ns\")\n    println(\"  Allocations: $(backward_bench.memory) bytes\")\nend\n\nprofile_transforms()\n\n# Julia profiling\nfunction profile_detailed()\n    sh = rand(get_nlm(cfg))\n    \n    Profile.clear()\n    @profile begin\n        for i in 1:100\n            spatial = synthesize(cfg, sh)\n        end\n    end\n    \n    Profile.print()\nend\n\ndestroy_config(cfg)","category":"page"},{"location":"performance/#Custom-Performance-Metrics","page":"Performance Guide","title":"Custom Performance Metrics","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using SHTnsKit\n\nfunction performance_report(cfg, n_runs=100)\n    # Warm up\n    sh_test = rand(get_nlm(cfg))\n    for i in 1:5\n        synthesize(cfg, sh_test)\n    end\n    \n    # Collect metrics\n    times = Float64[]\n    \n    for i in 1:n_runs\n        sh = rand(get_nlm(cfg))\n        \n        time = @elapsed begin\n            spatial = synthesize(cfg, sh)\n        end\n        \n        push!(times, time)\n    end\n    \n    # Statistics\n    mean_time = mean(times)\n    std_time = std(times)\n    min_time = minimum(times)\n    max_time = maximum(times)\n    \n    # Compute derived metrics\n    lmax = get_lmax(cfg)\n    operations_per_sec = 1.0 / mean_time\n    points_per_sec = (get_nlat(cfg) * get_nphi(cfg)) / mean_time\n    \n    println(\"Performance Report (lmax=$lmax, $n_runs runs):\")\n    println(\"  Mean time: $(mean_time*1000)ms (±$(std_time*1000)ms)\")\n    println(\"  Min/Max: $(min_time*1000)ms / $(max_time*1000)ms\")\n    println(\"  Transforms/sec: $(operations_per_sec)\")\n    println(\"  Points/sec: $(points_per_sec)\")\n    println(\"  Grid efficiency: $(get_nlm(cfg)/(get_nlat(cfg)*get_nphi(cfg)))\")\nend\n\ncfg = create_gauss_config(32, 32)\nperformance_report(cfg)\ndestroy_config(cfg)","category":"page"},{"location":"performance/#Optimization-Checklist","page":"Performance Guide","title":"Optimization Checklist","text":"","category":"section"},{"location":"performance/#Before-Optimization","page":"Performance Guide","title":"Before Optimization","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"[ ] Profile your code to identify bottlenecks\n[ ] Understand your problem's computational characteristics\n[ ] Measure baseline performance","category":"page"},{"location":"performance/#Threading-Optimization-2","page":"Performance Guide","title":"Threading Optimization","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"[ ] Set OMP_NUM_THREADS appropriately\n[ ] Use set_optimal_threads() for automatic tuning\n[ ] Disable threading in other libraries (BLAS, FFTW)\n[ ] Consider NUMA topology for large systems","category":"page"},{"location":"performance/#Memory-Optimization-2","page":"Performance Guide","title":"Memory Optimization","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"[ ] Pre-allocate buffers for repeated operations\n[ ] Use in-place transforms when possible\n[ ] Process data in chunks for large datasets\n[ ] Monitor memory usage and fragmentation","category":"page"},{"location":"performance/#Algorithm-Optimization","page":"Performance Guide","title":"Algorithm Optimization","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"[ ] Minimize backward transforms (analysis)\n[ ] Choose appropriate grid type (Gauss vs regular)\n[ ] Batch operations when possible\n[ ] Cache frequently used configurations","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"<!– GPU optimization checklist removed –>","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"[ ] Use appropriate batch sizes","category":"page"},{"location":"performance/#System-Level-Optimization","page":"Performance Guide","title":"System-Level Optimization","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"[ ] Use high-performance BLAS library\n[ ] Enable CPU optimizations (AVX, etc.)\n[ ] Consider process/thread affinity\n[ ] Monitor system resource utilization","category":"page"},{"location":"performance/#Performance-Validation","page":"Performance Guide","title":"Performance Validation","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"[ ] Compare with baseline measurements\n[ ] Verify numerical accuracy after optimization\n[ ] Test with realistic problem sizes\n[ ] Document performance characteristics","category":"page"},{"location":"performance/#Common-Performance-Pitfalls","page":"Performance Guide","title":"Common Performance Pitfalls","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Thread Oversubscription: Too many threads can hurt performance\nMemory Allocation: Repeated allocation in inner loops\nWrong Grid Type: Regular grids when Gauss would suffice\nUnnecessary Transforms: Computing both directions when only one needed\nPerformance pitfalls: array allocations in hot loops, oversubscription of threads","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Following these guidelines will help you achieve optimal performance for your specific SHTnsKit.jl applications.","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Complete reference for all SHTnsKit.jl functions and types.","category":"page"},{"location":"api/#Configuration-Management","page":"API Reference","title":"Configuration Management","text":"","category":"section"},{"location":"api/#Configuration-Creation","page":"API Reference","title":"Configuration Creation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"create_config(lmax; mmax=lmax, mres=1, nlat=lmax+2, nlon=max(2*lmax+1,4),\n              norm=:orthonormal, cs_phase=true, real_norm=false, robert_form=false,\n              grid_type=:gauss) → SHTConfig","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Create a configuration with specified parameters. Currently grid_type = :gauss is supported and forwards to create_gauss_config.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Notes:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Auto-corrects undersized grids to satisfy accuracy constraints:\nEnsures nlat ≥ lmax+1 (Gauss–Legendre quadrature exactness)\nEnsures nlon ≥ 2*mmax+1 (resolve azimuthal orders up to mmax)\nA legacy form create_config(::Type{T}, lmax, nlat, mres; ...) is also accepted; the type is ignored.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"cfg = create_config(32; nlat=30, nlon=60)  # adjusted to nlat=33, nlon=65","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"create_gauss_config(lmax, nlat; mmax=lmax, mres=1, nlon=max(2*lmax+1,4),\n                    norm=:orthonormal, cs_phase=true, real_norm=false,\n                    robert_form=false) → SHTConfig","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Create configuration with Gauss–Legendre grid. Requires nlat ≥ lmax+1 and nlon ≥ 2*mmax+1.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"cfg = create_gauss_config(32, 34; nlon=65)\nnlat, nphi = get_nlat(cfg), get_nphi(cfg)  # 34 × 65","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"create_regular_config(lmax, mmax) → SHTnsConfig","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Create configuration with regular equiangular grid.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"lmax::Int: Maximum degree  \nmmax::Int: Maximum order","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns: SHTnsConfig with regular grid setup","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"cfg = create_regular_config(32, 32)\nnlat, nphi = get_nlat(cfg), get_nphi(cfg)  # 65 × 65","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"<!– GPU configuration is not supported in this package –>","category":"page"},{"location":"api/#Configuration-Queries","page":"API Reference","title":"Configuration Queries","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"get_lmax(cfg::SHTnsConfig) → Int","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Get maximum spherical harmonic degree.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"get_mmax(cfg::SHTnsConfig) → Int  ","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Get maximum spherical harmonic order.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"get_nlat(cfg::SHTnsConfig) → Int","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Get number of latitude points in spatial grid.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"get_nphi(cfg::SHTnsConfig) → Int","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Get number of longitude points in spatial grid.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"get_nlm(cfg::SHTnsConfig) → Int","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Get total number of (l,m) spectral coefficients.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"For the real basis, coefficients are stored for m ≥ 0.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"lmidx(cfg::SHTnsConfig, l::Int, m::Int) → Int","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Get linear index (1‑based) for spherical harmonic coefficient (l, m≥0).","category":"page"},{"location":"api/#Grid-Information","page":"API Reference","title":"Grid Information","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"get_theta(cfg::SHTnsConfig, i::Int) → Real\nget_phi(cfg::SHTnsConfig, j::Int) → Real","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Access single grid coordinates by index.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SHTnsKit.create_coordinate_matrices(cfg::SHTnsConfig) → (θ::Matrix, φ::Matrix)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Create colatitude and longitude matrices for the grid.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"get_gauss_weights(cfg::SHTnsConfig) → Vector{Float64}","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Get Gaussian quadrature weights (for Gauss grids only).","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns: Vector of integration weights","category":"page"},{"location":"api/#Configuration-Cleanup","page":"API Reference","title":"Configuration Cleanup","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"destroy_config(cfg::SHTnsConfig) → Nothing","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Free memory associated with configuration. Always call after use.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"cfg = create_gauss_config(32, 32)\n# ... use configuration ...\ndestroy_config(cfg)","category":"page"},{"location":"api/#Scalar-Field-Transforms","page":"API Reference","title":"Scalar Field Transforms","text":"","category":"section"},{"location":"api/#Memory-Allocation","page":"API Reference","title":"Memory Allocation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"allocate_spectral(cfg::SHTnsConfig) → Vector{Float64}","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Allocate array for spectral coefficients.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns: Zero-initialized vector of length get_nlm(cfg)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"allocate_spatial(cfg::SHTnsConfig) → Matrix{Float64}","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Allocate array for spatial field values.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns: Zero-initialized matrix of size (get_nlat(cfg), get_nphi(cfg))","category":"page"},{"location":"api/#Forward-Transform-(Synthesis)","page":"API Reference","title":"Forward Transform (Synthesis)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"synthesize(cfg::SHTnsConfig, sh::Vector) → Matrix{Float64}","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Transform from spectral to spatial domain (spherical harmonic synthesis).","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"sh::Vector{Float64}: Spectral coefficients of length get_nlm(cfg)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns: Spatial field matrix (nlat × nphi)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"cfg = create_gauss_config(16, 16)\nsh = rand(get_nlm(cfg))\nspatial = synthesize(cfg, sh)  # 17×33 matrix","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"synthesize!(cfg::SHTnsConfig, sh::Vector, spatial::Matrix) → Nothing","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"In-place synthesis (avoids allocation).","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"sh::Vector{Float64}: Input spectral coefficients\nspatial::Matrix{Float64}: Output spatial field (modified)","category":"page"},{"location":"api/#Backward-Transform-(Analysis)","page":"API Reference","title":"Backward Transform (Analysis)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"analyze(cfg::SHTnsConfig, spatial::Matrix) → Vector{Float64}","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Transform from spatial to spectral domain (spherical harmonic analysis).","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"spatial::Matrix{Float64}: Spatial field (nlat × nphi)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns: Spectral coefficients vector of length get_nlm(cfg)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"cfg = create_gauss_config(16, 16)\nspatial = rand(get_nlat(cfg), get_nphi(cfg))\nsh = analyze(cfg, spatial)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"analyze!(cfg::SHTnsConfig, spatial::Matrix, sh::Vector) → Nothing","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"In-place analysis (avoids allocation).","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"spatial::Matrix{Float64}: Input spatial field\nsh::Vector{Float64}: Output spectral coefficients (modified)","category":"page"},{"location":"api/#Complex-Field-Transforms","page":"API Reference","title":"Complex Field Transforms","text":"","category":"section"},{"location":"api/#Memory-Allocation-2","page":"API Reference","title":"Memory Allocation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"allocate_complex_spectral(cfg::SHTnsConfig) → Vector{ComplexF64}","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Allocate array for complex spectral coefficients.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"allocate_complex_spatial(cfg::SHTnsConfig) → Matrix{ComplexF64}","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Allocate array for complex spatial field values.","category":"page"},{"location":"api/#Complex-Transforms","page":"API Reference","title":"Complex Transforms","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"synthesize_complex(cfg::SHTnsConfig, sh::Vector{ComplexF64}) → Matrix{ComplexF64}","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Complex field synthesis.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"cfg = create_gauss_config(16, 16)\nsh_complex = rand(ComplexF64, get_nlm(cfg))\nspatial_complex = synthesize_complex(cfg, sh_complex)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"analyze_complex(cfg::SHTnsConfig, spatial::Matrix{ComplexF64}) → Vector{ComplexF64}","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Complex field analysis.","category":"page"},{"location":"api/#Vector-Field-Transforms","page":"API Reference","title":"Vector Field Transforms","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Vector fields on the sphere are decomposed into spheroidal and toroidal components:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Spheroidal: Poloidal component (has radial component)\nToroidal: Azimuthal component (purely horizontal)","category":"page"},{"location":"api/#Vector-Synthesis","page":"API Reference","title":"Vector Synthesis","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"synthesize_vector(cfg::SHTnsConfig, S_lm::Vector, T_lm::Vector) → (Vθ::Matrix, Vφ::Matrix)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Synthesize vector field from spheroidal and toroidal coefficients.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"S_lm::Vector{Float64}: Spheroidal (poloidal) coefficients\nT_lm::Vector{Float64}: Toroidal coefficients","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Vθ::Matrix{Float64}: Colatitude component\nVφ::Matrix{Float64}: Longitude component","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"cfg = create_gauss_config(20, 20)\nS_lm = rand(get_nlm(cfg))  # Spheroidal\nT_lm = rand(get_nlm(cfg))  # Toroidal\nVθ, Vφ = synthesize_vector(cfg, S_lm, T_lm)","category":"page"},{"location":"api/#Vector-Analysis","page":"API Reference","title":"Vector Analysis","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"analyze_vector(cfg::SHTnsConfig, Vθ::Matrix, Vφ::Matrix) → (S_lm::Vector, T_lm::Vector)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Analyze vector field into spheroidal and toroidal components.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Vθ::Matrix{Float64}: Colatitude component\nVφ::Matrix{Float64}: Longitude component","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"S_lm::Vector{Float64}: Spheroidal coefficients\nT_lm::Vector{Float64}: Toroidal coefficients","category":"page"},{"location":"api/#Spatial-Operators","page":"API Reference","title":"Spatial Operators","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SHTnsKit.spatial_derivative_phi(cfg::SHTnsConfig, spatial::Matrix) → Matrix","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Exact φ‑derivative using FFT in longitude.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SHTnsKit.spatial_divergence(cfg::SHTnsConfig, Vθ::Matrix, Vφ::Matrix) → Matrix\nSHTnsKit.spatial_vorticity(cfg::SHTnsConfig, Vθ::Matrix, Vφ::Matrix) → Matrix","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Divergence and vertical vorticity of tangential vector fields on the unit sphere.","category":"page"},{"location":"api/#Field-Rotations","page":"API Reference","title":"Field Rotations","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"rotate_real!(cfg::SHTnsConfig, real_coeffs; alpha=0.0, beta=0.0, gamma=0.0) → Vector\nrotate_complex!(cfg::SHTnsConfig, cplx_coeffs; alpha=0.0, beta=0.0, gamma=0.0) → Vector{Complex}","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Rotate spectral coefficients in‑place using ZYZ Euler angles. For real fields, use rotate_real! or convert with real_to_complex_coeffs/complex_to_real_coeffs.","category":"page"},{"location":"api/#Power-Spectrum-Analysis","page":"API Reference","title":"Power Spectrum Analysis","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"power_spectrum(cfg::SHTnsConfig, sh::Vector) → Vector{Float64}","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Compute spherical harmonic power spectrum.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"sh::Vector{Float64}: Spectral coefficients","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns: Power per degree P(l) = Σₘ |aₗᵐ|²","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"cfg = create_gauss_config(32, 32)\nsh = rand(get_nlm(cfg))\npower = power_spectrum(cfg, sh)  # Length lmax+1\n# power[1] = l=0 power, power[2] = l=1 power, etc.","category":"page"},{"location":"api/#Threading-Control","page":"API Reference","title":"Threading Control","text":"","category":"section"},{"location":"api/#Thread-Management","page":"API Reference","title":"Thread Management","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"set_threading!(flag::Bool) → Bool\nget_threading() → Bool\nset_fft_threads(n::Integer) → Int\nget_fft_threads() → Int\nset_optimal_threads!() → (threads::Int, fft_threads::Int)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Enable/disable package parallel loops, control FFTW threads, or set a sensible configuration.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"summary = set_optimal_threads!()\nprintln(summary)\nset_fft_threads(4)\nprintln(get_fft_threads())","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"<!– GPU and MPI extensions are not applicable in this pure-Julia implementation. –>","category":"page"},{"location":"api/#Error-Handling","page":"API Reference","title":"Error Handling","text":"","category":"section"},{"location":"api/#Common-Errors","page":"API Reference","title":"Common Errors","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"BoundsError: Invalid lmax/mmax values\nAssertionError / DimensionMismatch: Array size mismatches","category":"page"},{"location":"api/#Best-Practices","page":"API Reference","title":"Best Practices","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Always check array sizes\n@assert length(sh) == get_nlm(cfg) \"Wrong spectral array size\"\n@assert size(spatial) == (get_nlat(cfg), get_nphi(cfg)) \"Wrong spatial array size\"\n\n# Always destroy configurations\ncfg = create_gauss_config(32, 32)\n# ... work with cfg ...\ndestroy_config(cfg)","category":"page"},{"location":"api/#Helper-Functions","page":"API Reference","title":"Helper Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"lmfromindex(cfg::SHTnsConfig, idx::Int) → (l::Int, m::Int)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"lmidx(cfg::SHTnsConfig, l::Int, m::Int) → Int","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"<!– Automatic differentiation specifics are omitted; functions are pure Julia and generally AD-friendly. –>","category":"page"},{"location":"performance_tips/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"This page summarizes practical tips to reduce allocations and improve locality and throughput in SHTnsKit.jl, especially for distributed (MPI + PencilArrays) use.","category":"page"},{"location":"performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"Reuse plans: Construct SHTPlan (serial) and distributed plans (DistAnalysisPlan, DistSphtorPlan, DistQstPlan) once per size and reuse. Plans hold FFT plans and working buffers to avoid per-call allocations.\nuserfft (distributed plans): When available in your PencilFFTs, set `userfft=true` in distributed plans to cut the (θ,k) spectral memory and accelerate real-output paths. The code falls back to complex FFTs when real transforms are not supported.\nwithspatialscratch (vector/QST): Enable with_spatial_scratch=true to keep a single complex (θ,φ) scratch in the plan. This removes per-call iFFT allocations for real outputs. Default remains off to minimize footprint.\nPrecomputed Legendre tables: On fixed grids, call enable_plm_tables!(cfg) to precompute plm_tables and dplm_tables. They provide identical results to on-the-fly recurrences and usually reduce CPU cost.\nThreading inside rank: For large lmax, enable Julia threads and (optionally) FFTW threads. Use set_optimal_threads!() or tune with set_threading!() and set_fft_threads() to match your core layout.\nLoopVectorization: If available, analysis_turbo/synthesis_turbo and related helpers can accelerate inner loops. Guard with using LoopVectorization.\nData locality by m: Keep Alm distributed by m throughout your pipeline to avoid dense gathers. The distributed plans in this package consume and produce m-sliced data to preserve cache locality.","category":"page"},{"location":"advanced/#Advanced-Usage-Patterns","page":"Advanced Usage","title":"Advanced Usage Patterns","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"This guide covers sophisticated usage patterns and advanced techniques for experienced SHTnsKit.jl users.","category":"page"},{"location":"advanced/#Advanced-Configuration-Management","page":"Advanced Usage","title":"Advanced Configuration Management","text":"","category":"section"},{"location":"advanced/#Configuration-Factories","page":"Advanced Usage","title":"Configuration Factories","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\n\n# Create a factory for consistent configuration creation\nstruct SHTnsConfigFactory\n    default_lmax::Int\n    cache::Dict{Tuple{Int,Int}, SHTnsConfig}\nend\n\nfunction SHTnsConfigFactory(lmax::Int=64)\n    SHTnsConfigFactory(lmax, Dict())\nend\n\nfunction get_config(factory::SHTnsConfigFactory, lmax::Int, mmax::Int)\n    key = (lmax, mmax)\n    if !haskey(factory.cache, key)\n        cfg = create_gauss_config(lmax, mmax)\n        factory.cache[key] = cfg\n    end\n    return factory.cache[key]\nend\n\nfunction cleanup!(factory::SHTnsConfigFactory)\n    for cfg in values(factory.cache)\n        destroy_config(cfg)\n    end\n    empty!(factory.cache)\nend\n\n# Usage\nfactory = SHTnsConfigFactory()\ncfg32 = get_config(factory, 32, 32)\ncfg64 = get_config(factory, 64, 64)\n# ... use configurations ...\ncleanup!(factory)","category":"page"},{"location":"advanced/#Dynamic-Resolution-Adaptation","page":"Advanced Usage","title":"Dynamic Resolution Adaptation","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\n\nmutable struct AdaptiveSpectralTransform\n    current_lmax::Int\n    max_lmax::Int\n    configs::Dict{Int, SHTnsConfig}\n    tolerance::Float64\nend\n\nfunction AdaptiveSpectralTransform(max_lmax::Int, tolerance::Float64=1e-10)\n    AdaptiveSpectralTransform(16, max_lmax, Dict{Int, SHTnsConfig}(), tolerance)\nend\n\nfunction get_config!(transform::AdaptiveSpectralTransform, lmax::Int)\n    if !haskey(transform.configs, lmax)\n        transform.configs[lmax] = create_gauss_config(lmax, lmax)\n    end\n    return transform.configs[lmax]\nend\n\nfunction adaptive_analyze(transform::AdaptiveSpectralTransform, field::Matrix{Float64})\n    lmax = transform.current_lmax\n    \n    while lmax <= transform.max_lmax\n        cfg = get_config!(transform, lmax)\n        \n        # Interpolate field to current resolution if needed\n        field_resized = resize_spatial_field(field, cfg)\n        \n        # Analyze\n        sh = analyze(cfg, field_resized)\n        \n        # Check convergence by looking at high-degree coefficients\n        high_degree_power = sum(abs2, sh[end-min(10, div(length(sh), 4)):end])\n        total_power = sum(abs2, sh)\n        \n        if high_degree_power / total_power < transform.tolerance\n            transform.current_lmax = lmax\n            return sh, lmax\n        end\n        \n        lmax = min(lmax * 2, transform.max_lmax)\n    end\n    \n    # Maximum resolution reached\n    cfg = get_config!(transform, transform.max_lmax)\n    field_resized = resize_spatial_field(field, cfg)\n    sh = analyze(cfg, field_resized)\n    transform.current_lmax = transform.max_lmax\n    \n    return sh, transform.max_lmax\nend\n\nfunction cleanup!(transform::AdaptiveSpectralTransform)\n    for cfg in values(transform.configs)\n        destroy_config(cfg)\n    end\n    empty!(transform.configs)\nend","category":"page"},{"location":"advanced/#Spectral-Domain-Operations","page":"Advanced Usage","title":"Spectral Domain Operations","text":"","category":"section"},{"location":"advanced/#Custom-Spectral-Filtering","page":"Advanced Usage","title":"Custom Spectral Filtering","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\n\nfunction create_spectral_filter(lmax::Int; \n                               low_pass::Union{Int,Nothing}=nothing,\n                               high_pass::Union{Int,Nothing}=nothing,\n                               band_pass::Union{Tuple{Int,Int},Nothing}=nothing)\n    \n    filter = ones(Float64, (lmax+1)*(lmax+2)÷2)\n    \n    cfg_temp = create_gauss_config(lmax, lmax)\n    \n    for i in 1:length(filter)\n        l, m = lm_from_index(cfg_temp, i)\n        \n        if low_pass !== nothing && l > low_pass\n            filter[i] = 0.0\n        elseif high_pass !== nothing && l < high_pass\n            filter[i] = 0.0\n        elseif band_pass !== nothing\n            l_min, l_max = band_pass\n            if l < l_min || l > l_max\n                filter[i] = 0.0\n            end\n        end\n    end\n    \n    destroy_config(cfg_temp)\n    return filter\nend\n\nfunction apply_spectral_filter!(sh::Vector{Float64}, filter::Vector{Float64})\n    @assert length(sh) == length(filter) \"Filter size mismatch\"\n    sh .*= filter\n    return sh\nend\n\n# Example: Smooth a noisy field\ncfg = create_gauss_config(64, 64)\nnoisy_field = rand(get_nlat(cfg), get_nphi(cfg))\n\n# Low-pass filter (keep only l ≤ 20)\nsh = analyze(cfg, noisy_field)\nlowpass_filter = create_spectral_filter(64, low_pass=20)\napply_spectral_filter!(sh, lowpass_filter)\nsmooth_field = synthesize(cfg, sh)\n\ndestroy_config(cfg)","category":"page"},{"location":"advanced/#Spectral-Derivative-Operations","page":"Advanced Usage","title":"Spectral Derivative Operations","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\n\nfunction spectral_laplacian(cfg::SHTnsConfig, sh::Vector{Float64})\n    # ∇²f has spectral coefficients: -l(l+1) * f_lm\n    laplacian_sh = copy(sh)\n    \n    for i in 1:length(sh)\n        l, m = lm_from_index(cfg, i)\n        laplacian_sh[i] *= -l * (l + 1)\n    end\n    \n    return laplacian_sh\nend\n\nfunction spectral_horizontal_gradient(cfg::SHTnsConfig, sh::Vector{Float64})\n    # Returns (∂f/∂θ, ∂f/∂φ/sin(θ)) in spectral domain\n    # These are vector field components\n    \n    # This is complex - need to compute derivatives of Y_l^m\n    # Implementation depends on SHTns internal representation\n    # For now, use spatial domain computation\n    \n    spatial = synthesize(cfg, sh)\n    θ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n    \n    # Finite differences (not optimal, but illustrative)\n    dθ = θ[2,1] - θ[1,1]\n    dφ = φ[1,2] - φ[1,1]\n    \n    ∂f_∂θ = similar(spatial)\n    ∂f_∂φ = similar(spatial)\n    \n    # Central differences\n    ∂f_∂θ[2:end-1, :] = (spatial[3:end, :] - spatial[1:end-2, :]) / (2*dθ)\n    ∂f_∂φ[:, 2:end-1] = (spatial[:, 3:end] - spatial[:, 1:end-2]) / (2*dφ)\n    \n    # Handle boundaries (simplified)\n    ∂f_∂θ[[1,end], :] = ∂f_∂θ[[2,end-1], :]\n    ∂f_∂φ[:, [1,end]] = ∂f_∂φ[:, [2,end-1]]\n    \n    return ∂f_∂θ, ∂f_∂φ\nend\n\n# Example: Compute and analyze gradients\ncfg = create_gauss_config(32, 32)\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\ntest_field = @. sin(3θ) * cos(2φ)\n\nsh = analyze(cfg, test_field)\n∂f_∂θ, ∂f_∂φ = spectral_horizontal_gradient(cfg, sh)\n\nprintln(\"Gradient magnitudes:\")\nprintln(\"  ∂f/∂θ: \", extrema(∂f_∂θ))\nprintln(\"  ∂f/∂φ: \", extrema(∂f_∂φ))\n\ndestroy_config(cfg)","category":"page"},{"location":"advanced/#Multi-Field-Processing-Patterns","page":"Advanced Usage","title":"Multi-Field Processing Patterns","text":"","category":"section"},{"location":"advanced/#Coherent-Transform-Pipeline","page":"Advanced Usage","title":"Coherent Transform Pipeline","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\n\nstruct SpectralPipeline\n    cfg::SHTnsConfig\n    stages::Vector{Function}\n    buffers::Dict{Symbol, Any}\nend\n\nfunction SpectralPipeline(lmax::Int, mmax::Int)\n    cfg = create_gauss_config(lmax, mmax)\n    stages = Function[]\n    buffers = Dict{Symbol, Any}()\n    \n    # Pre-allocate common buffers\n    buffers[:sh_temp] = allocate_spectral(cfg)\n    buffers[:spatial_temp] = allocate_spatial(cfg)\n    \n    SpectralPipeline(cfg, stages, buffers)\nend\n\nfunction add_stage!(pipeline::SpectralPipeline, stage_func::Function)\n    push!(pipeline.stages, stage_func)\nend\n\nfunction process(pipeline::SpectralPipeline, input_field::Matrix{Float64})\n    # Initial analysis\n    analyze!(pipeline.cfg, input_field, pipeline.buffers[:sh_temp])\n    \n    # Apply all stages\n    for stage in pipeline.stages\n        stage(pipeline.cfg, pipeline.buffers)\n    end\n    \n    # Final synthesis\n    synthesize!(pipeline.cfg, pipeline.buffers[:sh_temp], pipeline.buffers[:spatial_temp])\n    \n    return copy(pipeline.buffers[:spatial_temp])\nend\n\nfunction cleanup!(pipeline::SpectralPipeline)\n    destroy_config(pipeline.cfg)\nend\n\n# Example pipeline: smooth -> amplify low modes -> threshold\npipeline = SpectralPipeline(32, 32)\n\n# Stage 1: Low-pass filter\nadd_stage!(pipeline, function(cfg, buffers)\n    sh = buffers[:sh_temp]\n    for i in 1:length(sh)\n        l, m = lm_from_index(cfg, i)\n        if l > 16\n            sh[i] = 0.0\n        end\n    end\nend)\n\n# Stage 2: Amplify low modes\nadd_stage!(pipeline, function(cfg, buffers)\n    sh = buffers[:sh_temp]\n    for i in 1:length(sh)\n        l, m = lm_from_index(cfg, i)\n        if l <= 8\n            sh[i] *= 2.0\n        end\n    end\nend)\n\n# Process data\ntest_field = rand(get_nlat(pipeline.cfg), get_nphi(pipeline.cfg))\nresult = process(pipeline, test_field)\n\ncleanup!(pipeline)","category":"page"},{"location":"advanced/#Batch-Transform-Manager","page":"Advanced Usage","title":"Batch Transform Manager","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\nusing Base.Threads\n\nstruct BatchTransformManager\n    configs::Dict{Int, SHTnsConfig}\n    thread_buffers::Vector{Dict{Symbol, Any}}\n    max_lmax::Int\nend\n\nfunction BatchTransformManager(max_lmax::Int=128)\n    configs = Dict{Int, SHTnsConfig}()\n    thread_buffers = [Dict{Symbol, Any}() for _ in 1:nthreads()]\n    BatchTransformManager(configs, thread_buffers, max_lmax)\nend\n\nfunction get_config!(manager::BatchTransformManager, lmax::Int)\n    if !haskey(manager.configs, lmax)\n        manager.configs[lmax] = create_gauss_config(lmax, lmax)\n    end\n    return manager.configs[lmax]\nend\n\nfunction get_buffers!(manager::BatchTransformManager, thread_id::Int, lmax::Int)\n    buffers = manager.thread_buffers[thread_id]\n    key = Symbol(\"buffers_$lmax\")\n    \n    if !haskey(buffers, key)\n        cfg = get_config!(manager, lmax)\n        buffers[key] = Dict(\n            :sh => allocate_spectral(cfg),\n            :spatial => allocate_spatial(cfg)\n        )\n    end\n    \n    return buffers[key]\nend\n\nfunction batch_process(manager::BatchTransformManager, \n                      fields::Vector{Matrix{Float64}}, \n                      lmax::Int,\n                      process_func::Function)\n    \n    results = Vector{Any}(undef, length(fields))\n    cfg = get_config!(manager, lmax)\n    \n    @threads for i in 1:length(fields)\n        thread_id = threadid()\n        buffers = get_buffers!(manager, thread_id, lmax)\n        \n        # Resize field if necessary\n        field = fields[i]\n        if size(field) != (get_nlat(cfg), get_nphi(cfg))\n            field = resize_spatial_field(field, cfg)\n        end\n        \n        # Transform\n        analyze!(cfg, field, buffers[:sh])\n        \n        # Process in spectral domain\n        result_sh = process_func(cfg, buffers[:sh])\n        \n        # Transform back\n        synthesize!(cfg, result_sh, buffers[:spatial])\n        \n        results[i] = copy(buffers[:spatial])\n    end\n    \n    return results\nend\n\nfunction cleanup!(manager::BatchTransformManager)\n    for cfg in values(manager.configs)\n        destroy_config(cfg)\n    end\n    empty!(manager.configs)\nend\n\n# Example: Batch low-pass filtering\nmanager = BatchTransformManager()\n\n# Generate test data\ntest_fields = [rand(65, 129) for _ in 1:100]\n\n# Process function: low-pass filter\nfunction lowpass_filter(cfg, sh)\n    result = copy(sh)\n    for i in 1:length(result)\n        l, m = lm_from_index(cfg, i)\n        if l > 20\n            result[i] = 0.0\n        end\n    end\n    return result\nend\n\n# Process batch\nfiltered_fields = batch_process(manager, test_fields, 64, lowpass_filter)\n\nprintln(\"Processed $(length(filtered_fields)) fields\")\n\ncleanup!(manager)","category":"page"},{"location":"advanced/#Advanced-Vector-Field-Analysis","page":"Advanced Usage","title":"Advanced Vector Field Analysis","text":"","category":"section"},{"location":"advanced/#Helmholtz-Decomposition","page":"Advanced Usage","title":"Helmholtz Decomposition","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\n\nfunction helmholtz_decomposition(cfg::SHTnsConfig, u::Matrix{Float64}, v::Matrix{Float64})\n    # Decompose vector field into rotational and divergent parts\n    # u = u_rot + u_div, v = v_rot + v_div\n    \n    # Get spheroidal and toroidal components\n    S_lm, T_lm = analyze_vector(cfg, u, v)\n    \n    # Rotational part (from toroidal component)\n    u_rot, v_rot = synthesize_vector(cfg, zeros(length(S_lm)), T_lm)\n    \n    # Divergent part (from spheroidal component)  \n    u_div, v_div = synthesize_vector(cfg, S_lm, zeros(length(T_lm)))\n    \n    return (u_rot, v_rot), (u_div, v_div), (S_lm, T_lm)\nend\n\nfunction vector_field_properties(cfg::SHTnsConfig, u::Matrix{Float64}, v::Matrix{Float64})\n    # Compute various properties of vector field\n    \n    (u_rot, v_rot), (u_div, v_div), (S_lm, T_lm) = helmholtz_decomposition(cfg, u, v)\n    \n    # Energy in each component\n    rot_energy = sum(u_rot.^2 + v_rot.^2)\n    div_energy = sum(u_div.^2 + v_div.^2)\n    total_energy = sum(u.^2 + v.^2)\n    \n    # Spectral energies\n    spheroidal_energy = sum(abs2, S_lm)\n    toroidal_energy = sum(abs2, T_lm)\n    \n    return Dict(\n        :rotational_fraction => rot_energy / total_energy,\n        :divergent_fraction => div_energy / total_energy,\n        :spheroidal_energy => spheroidal_energy,\n        :toroidal_energy => toroidal_energy,\n        :total_spectral_energy => spheroidal_energy + toroidal_energy\n    )\nend\n\n# Example analysis\ncfg = create_gauss_config(48, 48)\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n\n# Create test vector field with known properties\nu = @. 10 * sin(2θ) * cos(φ)    # Mostly divergent\nv = @. 5 * cos(θ) * sin(2φ)     # Mixed\n\nproperties = vector_field_properties(cfg, u, v)\n\nprintln(\"Vector Field Analysis:\")\nfor (key, value) in properties\n    println(\"  $key: $value\")\nend\n\ndestroy_config(cfg)","category":"page"},{"location":"advanced/#Enstrophy-and-Energy-Cascade-Analysis","page":"Advanced Usage","title":"Enstrophy and Energy Cascade Analysis","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\n\nfunction compute_enstrophy_spectrum(cfg::SHTnsConfig, u::Matrix{Float64}, v::Matrix{Float64})\n    # Enstrophy Z(l) = l(l+1) * |ω_l|² where ω is vorticity\n    \n    # Get toroidal component (related to vorticity)\n    S_lm, T_lm = analyze_vector(cfg, u, v)\n    \n    # Compute enstrophy per degree\n    lmax = get_lmax(cfg)\n    enstrophy = zeros(lmax + 1)\n    \n    for i in 1:length(T_lm)\n        l, m = lm_from_index(cfg, i)\n        enstrophy[l + 1] += l * (l + 1) * abs2(T_lm[i])\n    end\n    \n    return enstrophy\nend\n\nfunction compute_energy_spectrum(cfg::SHTnsConfig, u::Matrix{Float64}, v::Matrix{Float64})\n    # Kinetic energy E(l) = |u_l|²\n    \n    S_lm, T_lm = analyze_vector(cfg, u, v)\n    \n    lmax = get_lmax(cfg)\n    energy = zeros(lmax + 1)\n    \n    for i in 1:length(S_lm)\n        l, m = lm_from_index(cfg, i)\n        energy[l + 1] += abs2(S_lm[i]) + abs2(T_lm[i])\n    end\n    \n    return energy\nend\n\nfunction analyze_turbulent_cascade(cfg::SHTnsConfig, \n                                  velocity_fields::Vector{Tuple{Matrix{Float64}, Matrix{Float64}}})\n    # Analyze energy cascade in turbulent flow\n    \n    n_snapshots = length(velocity_fields)\n    lmax = get_lmax(cfg)\n    \n    mean_energy = zeros(lmax + 1)\n    mean_enstrophy = zeros(lmax + 1)\n    \n    for (u, v) in velocity_fields\n        energy = compute_energy_spectrum(cfg, u, v)\n        enstrophy = compute_enstrophy_spectrum(cfg, u, v)\n        \n        mean_energy .+= energy\n        mean_enstrophy .+= enstrophy\n    end\n    \n    mean_energy ./= n_snapshots\n    mean_enstrophy ./= n_snapshots\n    \n    # Find inertial range (power law behavior)\n    degrees = 1:lmax\n    \n    return Dict(\n        :degrees => degrees,\n        :energy_spectrum => mean_energy[2:end],  # Skip l=0\n        :enstrophy_spectrum => mean_enstrophy[2:end],\n        :energy_slope => fit_power_law_slope(degrees[5:end÷2], mean_energy[6:end÷2+1]),\n        :enstrophy_slope => fit_power_law_slope(degrees[5:end÷2], mean_enstrophy[6:end÷2+1])\n    )\nend\n\nfunction fit_power_law_slope(x, y)\n    # Simple linear fit in log-log space\n    log_x = log.(x)\n    log_y = log.(y[y .> 0])  # Avoid log(0)\n    \n    if length(log_y) < 2\n        return NaN\n    end\n    \n    # Linear regression\n    n = length(log_x)\n    sum_x = sum(log_x)\n    sum_y = sum(log_y[1:length(log_x)])\n    sum_xy = sum(log_x .* log_y[1:length(log_x)])\n    sum_x2 = sum(log_x.^2)\n    \n    slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x^2)\n    return slope\nend","category":"page"},{"location":"advanced/#Temporal-Evolution-and-Time-Series","page":"Advanced Usage","title":"Temporal Evolution and Time Series","text":"","category":"section"},{"location":"advanced/#Spectral-Time-Series-Analysis","page":"Advanced Usage","title":"Spectral Time Series Analysis","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\nusing FFTW\n\nstruct SpectralTimeSeries\n    cfg::SHTnsConfig\n    time_series::Vector{Vector{Float64}}  # Each element is sh coefficients\n    times::Vector{Float64}\n    lmax::Int\nend\n\nfunction SpectralTimeSeries(cfg::SHTnsConfig)\n    SpectralTimeSeries(cfg, Vector{Float64}[], Float64[], get_lmax(cfg))\nend\n\nfunction add_snapshot!(sts::SpectralTimeSeries, field::Matrix{Float64}, time::Float64)\n    sh = analyze(sts.cfg, field)\n    push!(sts.time_series, sh)\n    push!(sts.times, time)\nend\n\nfunction temporal_power_spectrum(sts::SpectralTimeSeries, l::Int, m::Int)\n    # Get time evolution of specific (l,m) mode\n    idx = lmidx(sts.cfg, l, m)\n    \n    mode_evolution = [sh[idx] for sh in sts.time_series]\n    \n    # Compute temporal Fourier transform\n    fft_result = fft(mode_evolution)\n    power_spectrum = abs2.(fft_result)\n    \n    # Frequency axis\n    dt = length(sts.times) > 1 ? sts.times[2] - sts.times[1] : 1.0\n    frequencies = fftfreq(length(mode_evolution), 1/dt)\n    \n    return frequencies, power_spectrum\nend\n\nfunction mode_correlation_matrix(sts::SpectralTimeSeries)\n    # Compute correlation between different spherical harmonic modes\n    \n    n_modes = length(sts.time_series[1])\n    n_times = length(sts.time_series)\n    \n    # Create matrix: modes × time\n    mode_matrix = zeros(n_modes, n_times)\n    for (i, sh) in enumerate(sts.time_series)\n        mode_matrix[:, i] = sh\n    end\n    \n    # Compute correlation matrix\n    correlation_matrix = cor(mode_matrix')\n    \n    return correlation_matrix\nend\n\nfunction dominant_mode_evolution(sts::SpectralTimeSeries, n_modes::Int=10)\n    # Find most energetic modes and track their evolution\n    \n    # Compute mean energy per mode\n    mean_energies = zeros(length(sts.time_series[1]))\n    for sh in sts.time_series\n        mean_energies .+= abs2.(sh)\n    end\n    mean_energies ./= length(sts.time_series)\n    \n    # Find dominant modes\n    dominant_indices = sortperm(mean_energies, rev=true)[1:n_modes]\n    \n    # Extract evolution\n    evolutions = []\n    for idx in dominant_indices\n        l, m = lm_from_index(sts.cfg, idx)\n        evolution = [sh[idx] for sh in sts.time_series]\n        push!(evolutions, (l=l, m=m, evolution=evolution, mean_energy=mean_energies[idx]))\n    end\n    \n    return evolutions\nend\n\n# Example usage\ncfg = create_gauss_config(32, 32)\nsts = SpectralTimeSeries(cfg)\n\n# Generate synthetic time series (e.g., decaying turbulence)\nfor t in 0:0.1:10.0\n    # Synthetic field with time evolution\n    θ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n    decay_factor = exp(-0.1 * t)\n    field = decay_factor * (\n        sin(3θ) .* cos(2φ) +\n        0.5 * sin(5θ) .* cos(4φ) * cos(0.5π * t) +\n        randn(size(θ)...) * 0.1\n    )\n    \n    add_snapshot!(sts, field, t)\nend\n\n# Analysis\ndominant_modes = dominant_mode_evolution(sts, 5)\nfor mode in dominant_modes\n    println(\"Mode l=$(mode.l), m=$(mode.m): mean energy = $(mode.mean_energy)\")\nend\n\n# Temporal spectrum of dominant mode\nif length(dominant_modes) > 0\n    l, m = dominant_modes[1].l, dominant_modes[1].m\n    freqs, power = temporal_power_spectrum(sts, l, m)\n    println(\"Temporal spectrum computed for mode ($l, $m)\")\nend\n\ndestroy_config(cfg)","category":"page"},{"location":"advanced/#Custom-Interpolation-and-Remapping","page":"Advanced Usage","title":"Custom Interpolation and Remapping","text":"","category":"section"},{"location":"advanced/#Adaptive-Mesh-Refinement-Interface","page":"Advanced Usage","title":"Adaptive Mesh Refinement Interface","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\n\nstruct AdaptiveMesh\n    base_cfg::SHTnsConfig\n    refined_regions::Vector{Dict{Symbol, Any}}\n    global_field::Union{Vector{Float64}, Nothing}\nend\n\nfunction AdaptiveMesh(base_lmax::Int)\n    base_cfg = create_gauss_config(base_lmax, base_lmax)\n    AdaptiveMesh(base_cfg, Dict{Symbol, Any}[], nothing)\nend\n\nfunction add_refined_region!(mesh::AdaptiveMesh, \n                           θ_center::Float64, φ_center::Float64, \n                           radius::Float64, refinement_lmax::Int)\n    \n    refined_cfg = create_gauss_config(refinement_lmax, refinement_lmax)\n    \n    region = Dict(\n        :center => (θ_center, φ_center),\n        :radius => radius,\n        :cfg => refined_cfg,\n        :lmax => refinement_lmax,\n        :local_field => nothing\n    )\n    \n    push!(mesh.refined_regions, region)\nend\n\nfunction interpolate_to_refined_region!(mesh::AdaptiveMesh, region_idx::Int)\n    if mesh.global_field === nothing\n        error(\"No global field set\")\n    end\n    \n    region = mesh.refined_regions[region_idx]\n    base_spatial = synthesize(mesh.base_cfg, mesh.global_field)\n    \n    # Extract region from global field (simplified interpolation)\n    θ_global, φ_global = SHTnsKit.create_coordinate_matrices(mesh.base_cfg)\n    θ_local, φ_local = SHTnsKit.create_coordinate_matrices(region[:cfg])\n    \n    # Simple nearest-neighbor interpolation (in practice, use proper interpolation)\n    local_spatial = zeros(size(θ_local))\n    \n    for i in 1:size(θ_local, 1), j in 1:size(θ_local, 2)\n        # Find nearest point in global grid\n        distances = (θ_global .- θ_local[i,j]).^2 + (φ_global .- φ_local[i,j]).^2\n        min_idx = argmin(distances)\n        local_spatial[i,j] = base_spatial[min_idx]\n    end\n    \n    # Analyze to get local spectral representation\n    region[:local_field] = analyze(region[:cfg], local_spatial)\nend\n\nfunction project_refined_to_global!(mesh::AdaptiveMesh, region_idx::Int)\n    region = mesh.refined_regions[region_idx]\n    \n    if region[:local_field] === nothing\n        error(\"No refined field in region $region_idx\")\n    end\n    \n    # Convert refined solution back to global grid\n    local_spatial = synthesize(region[:cfg], region[:local_field])\n    \n    # Project onto global spectral representation\n    # This requires careful handling of overlapping regions\n    \n    global_spatial = synthesize(mesh.base_cfg, mesh.global_field)\n    \n    # Weighted blending (simplified)\n    θ_center, φ_center = region[:center]\n    radius = region[:radius]\n    \n    θ_global, φ_global = SHTnsKit.create_coordinate_matrices(mesh.base_cfg)\n    θ_local, φ_local = SHTnsKit.create_coordinate_matrices(region[:cfg])\n    \n    # Apply refined solution in the local region\n    # (Proper implementation would use overlap integrals)\n    \n    mesh.global_field = analyze(mesh.base_cfg, global_spatial)\nend\n\nfunction cleanup!(mesh::AdaptiveMesh)\n    destroy_config(mesh.base_cfg)\n    for region in mesh.refined_regions\n        destroy_config(region[:cfg])\n    end\nend","category":"page"},{"location":"advanced/#Memory-Mapped-Large-Dataset-Processing","page":"Advanced Usage","title":"Memory-Mapped Large Dataset Processing","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\nusing Mmap\n\nstruct MemoryMappedSpectralData\n    file_path::String\n    cfg::SHTnsConfig\n    n_snapshots::Int\n    nlm::Int\n    mmap_array::Array{Float64, 2}  # nlm × n_snapshots\nend\n\nfunction create_mmap_spectral_data(file_path::String, cfg::SHTnsConfig, n_snapshots::Int)\n    nlm = get_nlm(cfg)\n    \n    # Create memory-mapped file\n    file_size = nlm * n_snapshots * sizeof(Float64)\n    \n    open(file_path, \"w+\") do io\n        write(io, zeros(UInt8, file_size))\n    end\n    \n    # Memory map the file\n    mmap_array = Mmap.mmap(file_path, Array{Float64, 2}, (nlm, n_snapshots))\n    \n    MemoryMappedSpectralData(file_path, cfg, n_snapshots, nlm, mmap_array)\nend\n\nfunction add_snapshot!(mmsd::MemoryMappedSpectralData, \n                      spatial_field::Matrix{Float64}, \n                      snapshot_idx::Int)\n    if snapshot_idx > mmsd.n_snapshots\n        error(\"Snapshot index $snapshot_idx exceeds capacity $(mmsd.n_snapshots)\")\n    end\n    \n    # Analyze and store directly in memory-mapped array\n    sh = analyze(mmsd.cfg, spatial_field)\n    mmsd.mmap_array[:, snapshot_idx] = sh\nend\n\nfunction process_snapshots_streaming(mmsd::MemoryMappedSpectralData, \n                                   process_func::Function,\n                                   chunk_size::Int=100)\n    results = []\n    \n    n_chunks = div(mmsd.n_snapshots, chunk_size)\n    \n    for chunk in 1:n_chunks\n        start_idx = (chunk - 1) * chunk_size + 1\n        end_idx = min(chunk * chunk_size, mmsd.n_snapshots)\n        \n        # Process chunk\n        chunk_data = mmsd.mmap_array[:, start_idx:end_idx]\n        chunk_result = process_func(mmsd.cfg, chunk_data)\n        push!(results, chunk_result)\n        \n        # Optional: trigger garbage collection\n        if chunk % 10 == 0\n            GC.gc()\n        end\n    end\n    \n    return results\nend\n\nfunction compute_temporal_statistics(mmsd::MemoryMappedSpectralData)\n    # Compute statistics without loading all data into memory\n    \n    mean_spectrum = zeros(mmsd.nlm)\n    var_spectrum = zeros(mmsd.nlm)\n    \n    # First pass: compute mean\n    for i in 1:mmsd.n_snapshots\n        mean_spectrum .+= mmsd.mmap_array[:, i]\n    end\n    mean_spectrum ./= mmsd.n_snapshots\n    \n    # Second pass: compute variance\n    for i in 1:mmsd.n_snapshots\n        diff = mmsd.mmap_array[:, i] - mean_spectrum\n        var_spectrum .+= diff.^2\n    end\n    var_spectrum ./= (mmsd.n_snapshots - 1)\n    \n    return mean_spectrum, sqrt.(var_spectrum)\nend\n\nfunction cleanup!(mmsd::MemoryMappedSpectralData)\n    # Close memory mapping and optionally remove file\n    finalize(mmsd.mmap_array)\n    # rm(mmsd.file_path)  # Uncomment to delete file\nend\n\n# Example: Process large climate dataset\n# cfg = create_gauss_config(128, 128)\n# n_years = 100\n# n_snapshots_per_year = 365\n# total_snapshots = n_years * n_snapshots_per_year\n\n# mmsd = create_mmap_spectral_data(\"climate_data.bin\", cfg, total_snapshots)\n\n# # Add data (in practice, this would come from files)\n# for i in 1:total_snapshots\n#     synthetic_field = generate_climate_snapshot(i)  # User function\n#     add_snapshot!(mmsd, synthetic_field, i)\n# end\n\n# # Compute statistics\n# mean_spec, std_spec = compute_temporal_statistics(mmsd)\n\n# cleanup!(mmsd)\n# destroy_config(cfg)","category":"page"},{"location":"advanced/#Integration-with-External-Libraries","page":"Advanced Usage","title":"Integration with External Libraries","text":"","category":"section"},{"location":"advanced/#Interfacing-with-Climate-Models","page":"Advanced Usage","title":"Interfacing with Climate Models","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\n# using NCDatasets  # For NetCDF files\n\nfunction read_climate_model_output(file_path::String, variable::String, time_index::Int)\n    # Read data from NetCDF file (pseudo-code)\n    # In practice, use NCDatasets.jl or similar\n    \n    # data = NCDatasets.Dataset(file_path) do ds\n    #     ds[variable][:, :, time_index]\n    # end\n    \n    # For demonstration, create synthetic data\n    nlat, nlon = 96, 192  # Typical climate model resolution\n    data = rand(nlat, nlon)\n    \n    return data\nend\n\nfunction climate_model_to_shtns(data::Matrix{Float64}, target_lmax::Int)\n    # Convert climate model grid to SHTns format\n    \n    input_nlat, input_nlon = size(data)\n    \n    # Create appropriate configuration\n    cfg = create_regular_config(target_lmax, target_lmax)\n    target_nlat, target_nlon = get_nlat(cfg), get_nphi(cfg)\n    \n    # Interpolate to target grid (simplified)\n    if (input_nlat, input_nlon) != (target_nlat, target_nlon)\n        # Bilinear interpolation (in practice, use proper spherical interpolation)\n        data_interpolated = imresize(data, (target_nlat, target_nlon))\n    else\n        data_interpolated = data\n    end\n    \n    # Analyze\n    sh = analyze(cfg, data_interpolated)\n    \n    return cfg, sh\nend\n\nfunction process_climate_ensemble(file_paths::Vector{String}, \n                                variable::String, \n                                target_lmax::Int)\n    \n    ensemble_spectra = []\n    reference_cfg = nothing\n    \n    for file_path in file_paths\n        println(\"Processing: $file_path\")\n        \n        # Read multiple time steps\n        n_time_steps = get_time_dimension_size(file_path)  # User function\n        \n        for t in 1:min(n_time_steps, 100)  # Limit for example\n            data = read_climate_model_output(file_path, variable, t)\n            cfg, sh = climate_model_to_shtns(data, target_lmax)\n            \n            if reference_cfg === nothing\n                reference_cfg = cfg\n            end\n            \n            push!(ensemble_spectra, sh)\n        end\n    end\n    \n    return reference_cfg, ensemble_spectra\nend\n\n# Example usage\n# file_paths = [\"model1_output.nc\", \"model2_output.nc\", \"model3_output.nc\"]\n# cfg, ensemble = process_climate_ensemble(file_paths, \"temperature\", 64)\n\n# # Compute ensemble statistics\n# n_members = length(ensemble)\n# mean_spectrum = sum(ensemble) / n_members\n# variance_spectrum = sum([(sp - mean_spectrum).^2 for sp in ensemble]) / (n_members - 1)\n\n# println(\"Ensemble analysis complete\")\n# destroy_config(cfg)","category":"page"},{"location":"advanced/#Automatic-Differentiation-Integration","page":"Advanced Usage","title":"Automatic Differentiation Integration","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"SHTnsKit.jl provides seamless integration with Julia's automatic differentiation ecosystem through package extensions for ForwardDiff.jl and Zygote.jl.","category":"page"},{"location":"advanced/#ForwardDiff.jl-Support-(Forward-Mode-AD)","page":"Advanced Usage","title":"ForwardDiff.jl Support (Forward-Mode AD)","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Forward-mode automatic differentiation is ideal for functions with few inputs and many outputs, common in parameter estimation problems.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\nusing ForwardDiff\n\ncfg = create_gauss_config(16, 16)\n\n# Example: Parameter estimation for spherical harmonic coefficients\nfunction objective(params)\n    # Create spherical harmonic field from parameters\n    sh = zeros(get_nlm(cfg))\n    sh[1:length(params)] = params\n    \n    # Transform to spatial domain\n    spatial = synthesize(cfg, sh)\n    \n    # Compute some objective (e.g., match target pattern)\n    target = rand(size(spatial))\n    return sum((spatial - target).^2)\nend\n\n# Initial parameters\nparams₀ = rand(10)\n\n# Compute gradient using ForwardDiff\n∇f = ForwardDiff.gradient(objective, params₀)\n\n# Use gradient for optimization\nparams₁ = params₀ - 0.01 * ∇f\n\ndestroy_config(cfg)","category":"page"},{"location":"advanced/#Zygote.jl-Support-(Reverse-Mode-AD)","page":"Advanced Usage","title":"Zygote.jl Support (Reverse-Mode AD)","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Reverse-mode AD is ideal for functions with many inputs and few outputs, common in neural networks and optimization problems.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\nusing Zygote\n\ncfg = create_gauss_config(16, 16)\n\n# Example: Optimizing spatial field patterns\nfunction loss_function(spatial_field)\n    # Transform to spectral domain\n    sh = analyze(cfg, spatial_field)\n    \n    # Regularize high-frequency components\n    high_freq_penalty = sum(sh[end-20:end].^2)\n    \n    # Target smooth field\n    smooth_penalty = sum(abs2, spatial_field .- mean(spatial_field))\n    \n    return 0.1 * high_freq_penalty + smooth_penalty\nend\n\n# Initial spatial field\nspatial₀ = randn(get_nlat(cfg), get_nphi(cfg))\n\n# Compute gradient using Zygote\n∇L = Zygote.gradient(loss_function, spatial₀)[1]\n\n# Update field\nspatial₁ = spatial₀ - 0.01 * ∇L\n\ndestroy_config(cfg)","category":"page"},{"location":"advanced/#Advanced-AD-Patterns","page":"Advanced Usage","title":"Advanced AD Patterns","text":"","category":"section"},{"location":"advanced/#Differentiable-Vector-Field-Operations","page":"Advanced Usage","title":"Differentiable Vector Field Operations","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\nusing ForwardDiff\n\ncfg = create_gauss_config(12, 12)\n\nfunction vector_field_energy(params)\n    n = length(params) ÷ 2\n    S_lm = params[1:n]          # Spheroidal coefficients\n    T_lm = params[n+1:end]      # Toroidal coefficients\n    \n    # Synthesize vector field\n    Vθ, Vφ = synthesize_vector(cfg, S_lm, T_lm)\n    \n    # Compute kinetic energy\n    kinetic_energy = sum(Vθ.^2 + Vφ.^2)\n    \n    # Add enstrophy (related to vorticity)\n    _, T_reconstructed = analyze_vector(cfg, Vθ, Vφ)\n    enstrophy = sum(abs2, T_reconstructed)\n    \n    return 0.5 * kinetic_energy + 0.1 * enstrophy\nend\n\n# Optimize vector field parameters\nnlm = get_nlm(cfg)\nvector_params = randn(2 * nlm)\n\n# Gradient descent\nfor i in 1:10\n    grad = ForwardDiff.gradient(vector_field_energy, vector_params)\n    vector_params .-= 0.01 * grad\n    \n    energy = vector_field_energy(vector_params)\n    println(\"Iteration $i: Energy = $energy\")\nend\n\ndestroy_config(cfg)","category":"page"},{"location":"advanced/#Differentiable-Field-Rotations","page":"Advanced Usage","title":"Differentiable Field Rotations","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\nusing ForwardDiff\n\ncfg = create_gauss_config(16, 16)\n\n# Optimize rotation angles to match target field\nfunction rotation_objective(angles)\n    α, β, γ = angles\n    \n    # Original field\n    sh_original = rand(get_nlm(cfg))\n    \n    # Rotate field (in-place helper for real-basis coefficients)\n    sh_rotated = copy(sh_original)\n    rotate_real!(cfg, sh_rotated; alpha=α, beta=β, gamma=γ)\n    \n    # Target field (e.g., aligned with some axis)\n    sh_target = zeros(get_nlm(cfg))\n    sh_target[1] = 1.0  # Y₀⁰ mode only\n    \n    return sum((sh_rotated - sh_target).^2)\nend\n\n# Find optimal rotation angles\nangles₀ = [0.1, 0.1, 0.1]\n\nfor i in 1:20\n    grad = ForwardDiff.gradient(rotation_objective, angles₀)\n    angles₀ .-= 0.01 * grad\n    \n    obj = rotation_objective(angles₀)\n    println(\"Iteration $i: Objective = $obj, Angles = $angles₀\")\nend\n\ndestroy_config(cfg)","category":"page"},{"location":"advanced/#Neural-Differential-Equations-on-the-Sphere","page":"Advanced Usage","title":"Neural Differential Equations on the Sphere","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\nusing Zygote\n# using DifferentialEquations  # For ODE solving\n\ncfg = create_gauss_config(20, 20)\n\n# Define a neural ODE on the sphere using SHT\nfunction sphere_neural_ode!(du, u, p, t)\n    # u contains spherical harmonic coefficients\n    # p contains neural network parameters\n    \n    # Transform to spatial domain\n    spatial = synthesize(cfg, u)\n    \n    # Apply nonlinear transformation (neural network layer)\n    # This is a simplified version - real neural networks would be more complex\n    W, b = p[1:length(spatial)], p[length(spatial)+1:end]\n    transformed = tanh.(W .* spatial .+ b[1:size(spatial, 1), 1:size(spatial, 2)])\n    \n    # Transform back to spectral domain for time derivative\n    du .= analyze(cfg, transformed)\nend\n\n# Example usage would involve solving the ODE and differentiating through the solution","category":"page"},{"location":"advanced/#Performance-Considerations-for-AD","page":"Advanced Usage","title":"Performance Considerations for AD","text":"","category":"section"},{"location":"advanced/#Memory-Management","page":"Advanced Usage","title":"Memory Management","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using SHTnsKit\nusing ForwardDiff\n\ncfg = create_gauss_config(32, 32)\n\n# Pre-allocate buffers to avoid repeated allocation during AD\nstruct ADBuffers\n    sh_buffer::Vector{Float64}\n    spatial_buffer::Matrix{Float64}\n    grad_buffer::Vector{Float64}\nend\n\nfunction create_ad_buffers(cfg)\n    ADBuffers(\n        allocate_spectral(cfg),\n        allocate_spatial(cfg),\n        zeros(get_nlm(cfg))\n    )\nend\n\nbuffers = create_ad_buffers(cfg)\n\n# Use buffers in AD computations to reduce allocation\nfunction efficient_objective(params, buffers)\n    # Use pre-allocated buffers\n    buffers.sh_buffer[1:length(params)] = params\n    fill!(buffers.sh_buffer, 0.0)\n    buffers.sh_buffer[1:length(params)] = params\n    \n    synthesize!(cfg, buffers.sh_buffer, buffers.spatial_buffer)\n    \n    return sum(abs2, buffers.spatial_buffer)\nend\n\n# This version is more memory efficient\ngrad = ForwardDiff.gradient(p -> efficient_objective(p, buffers), rand(10))\n\ndestroy_config(cfg)","category":"page"},{"location":"advanced/#Choosing-Between-Forward-and-Reverse-Mode","page":"Advanced Usage","title":"Choosing Between Forward and Reverse Mode","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using BenchmarkTools\n\n# Rule of thumb:\n# - Use ForwardDiff when: n_parameters < n_outputs\n# - Use Zygote when: n_parameters > n_outputs\n\ncfg = create_gauss_config(16, 16)\nn_params = 50\nn_spatial = get_nlat(cfg) * get_nphi(cfg)\n\nprintln(\"Parameters: $n_params, Spatial points: $n_spatial\")\n\nfunction test_objective(params)\n    sh = zeros(get_nlm(cfg))\n    sh[1:n_params] = params\n    spatial = synthesize(cfg, sh)\n    return sum(abs2, spatial)  # Single output\nend\n\nparams = rand(n_params)\n\nif n_params < n_spatial\n    println(\"ForwardDiff recommended (fewer parameters than outputs)\")\n    @btime ForwardDiff.gradient($test_objective, $params)\nelse\n    println(\"Zygote recommended (more parameters than outputs)\")\n    @btime Zygote.gradient($test_objective, $params)\nend\n\ndestroy_config(cfg)","category":"page"},{"location":"advanced/#Applications-in-Scientific-Computing","page":"Advanced Usage","title":"Applications in Scientific Computing","text":"","category":"section"},{"location":"advanced/#Inverse-Problems","page":"Advanced Usage","title":"Inverse Problems","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"# Parameter estimation from observations\nfunction solve_inverse_problem(observations, initial_guess, cfg)\n    using ForwardDiff\n    using Optim\n    \n    function forward_model(params)\n        # Convert parameters to spherical harmonic field\n        sh = param_to_sh(params, cfg)\n        return synthesize(cfg, sh)\n    end\n    \n    function objective(params)\n        predicted = forward_model(params)\n        return sum((observations - predicted).^2)\n    end\n    \n    # Use automatic differentiation for optimization\n    result = optimize(objective, initial_guess, BFGS(), \n                     autodiff=:forward)\n    \n    return result.minimizer\nend","category":"page"},{"location":"advanced/#Data-Assimilation","page":"Advanced Usage","title":"Data Assimilation","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"# Variational data assimilation with spherical harmonic background\nfunction variational_assimilation(observations, background_sh, obs_locations, cfg)\n    using Zygote\n    \n    function cost_function(analysis_sh)\n        # Background term\n        background_cost = sum((analysis_sh - background_sh).^2)\n        \n        # Observation term\n        analysis_spatial = synthesize(cfg, analysis_sh)\n        obs_cost = sum((analysis_spatial[obs_locations] - observations).^2)\n        \n        return 0.5 * (background_cost + obs_cost)\n    end\n    \n    # Minimize cost function using gradients\n    analysis_sh = copy(background_sh)\n    \n    for i in 1:100\n        grad = Zygote.gradient(cost_function, analysis_sh)[1]\n        analysis_sh .-= 0.01 * grad\n        \n        cost = cost_function(analysis_sh)\n        println(\"Iteration $i: Cost = $cost\")\n        \n        if norm(grad) < 1e-6\n            break\n        end\n    end\n    \n    return analysis_sh\nend","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"This comprehensive advanced usage guide demonstrates sophisticated patterns for expert users of SHTnsKit.jl, covering everything from configuration management to large-scale data processing, automatic differentiation, and integration with external scientific computing workflows.","category":"page"},{"location":"grids/#Grid-Types","page":"-","title":"Grid Types","text":"","category":"section"},{"location":"grids/","page":"-","title":"-","text":"SHTnsKit supports several latitude grids selected via shtns_set_grid flags:","category":"page"},{"location":"grids/","page":"-","title":"-","text":"Gauss (Gaussian quadrature): Exact for integrals up to degree 2*nlat-1. Use for highest accuracy. Suggested nlat = lmax+1, nphi ≥ 2*mmax+1.\nRegular equiangular without poles (regfast/regdct/quickinit): Midpoint latitudes `θi = (i+0.5)π/nlat. Fast to set up and compatible with FFT-friendly sampling. Weightswi = (π/nlat) sin(θi)` approximate the integral.\nRegular equiangular with poles (regpoles): `θi = i π/(nlat-1)including poles. Weights arewi = (π/(nlat-1)) sin(θi)`.","category":"page"},{"location":"grids/","page":"-","title":"-","text":"Use shtns_set_grid_auto to get suggested nlat/nphi depending on grid type. For best numerical exactness, prefer Gauss. For speed and compatibility with standard image-like sampling, prefer regular grids with precomputed Legendre tables via prepare_plm_tables!(cfg).","category":"page"},{"location":"examples/#Examples-Gallery","page":"Examples Gallery","title":"Examples Gallery","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Real-world examples and tutorials demonstrating SHTnsKit.jl capabilities, organized by difficulty level.","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"How to use this guide:","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Beginner: Start here if you're new to spherical harmonics\nIntermediate: For users comfortable with basic transforms\nAdvanced: Complex workflows and specialized applications","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Learning path: Work through the examples in order for the best learning experience.","category":"page"},{"location":"examples/#Beginner-Examples","page":"Examples Gallery","title":"Beginner Examples","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Start here if you're new to spherical harmonics. These examples teach fundamental concepts with simple, well-explained code.","category":"page"},{"location":"examples/#Example-1:-Your-First-Transform","page":"Examples Gallery","title":"Example 1: Your First Transform","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Goal: Learn the basic workflow of spherical harmonic transforms","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\n\n# Step 1: Create a configuration (like setting up your workspace)\ncfg = create_gauss_config(16, 16)  # Start small for learning\nprintln(\"Created configuration for degree up to 16\")\n\n# Step 2: Create a simple temperature pattern\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n# Simple pattern: warm equator (θ = π/2), cold poles (θ = 0, π)\ntemperature = @. 273.15 + 30 * sin(θ)^2  # Base temp + equatorial warming\n\nprintln(\"Temperature range: $(extrema(temperature)) K\")\n\n# Step 3: Transform to spherical harmonic coefficients (analysis)\nT_coeffs = analyze(cfg, temperature)\nprintln(\"Number of coefficients: \", length(T_coeffs))\n\n# Step 4: Find the most important coefficient\nmax_coeff_idx = argmax(abs.(T_coeffs))\nl, m = SHTnsKit.lm_from_index(cfg, max_coeff_idx)\nprintln(\"Strongest mode: l=$l, m=$m\")\n\n# Step 5: Reconstruct the original field (synthesis)\nT_reconstructed = synthesize(cfg, T_coeffs)\nerror = maximum(abs.(temperature - T_reconstructed))\nprintln(\"Reconstruction error: $error (should be tiny!)\")\n\ndestroy_config(cfg)","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Key concepts learned:","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Configuration setup (create_gauss_config)\nCreating realistic data patterns\nAnalysis: spatial → spectral (analyze)\nSynthesis: spectral → spatial (synthesize)\nUnderstanding (l,m) mode indices","category":"page"},{"location":"examples/#Example-2:-Pure-Spherical-Harmonic-Patterns","page":"Examples Gallery","title":"Example 2: Pure Spherical Harmonic Patterns","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Goal: Understand how individual spherical harmonic modes look","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\nusing Plots  # For visualization\n\ncfg = create_gauss_config(32, 32)\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n\n# Create pure Y_2^0 spherical harmonic (zonal mode)\nsh = zeros(get_nlm(cfg))\nidx = SHTnsKit.lmidx(cfg, 2, 0)  # l=2, m=0 (depends only on latitude)\nsh[idx] = 1.0\nprintln(\"Creating Y₂⁰ pattern (zonal, m=0)\")\n\n# Synthesize to spatial domain\nY20_pattern = synthesize(cfg, sh)\n\n# This creates a pattern that varies only with latitude\nprintln(\"Pattern statistics:\")\nprintln(\"  Min value: $(minimum(Y20_pattern))\")\nprintln(\"  Max value: $(maximum(Y20_pattern))\")\nprintln(\"  At north pole (θ=0): $(Y20_pattern[1,1])\")\nprintln(\"  At equator (θ=π/2): $(Y20_pattern[div(end,2),1])\")\n\n# Plot the pattern\nheatmap(φ*180/π, θ*180/π, Y20_pattern, \n        xlabel=\"Longitude (°)\", ylabel=\"Colatitude (°)\",\n        title=\"Y₂⁰ Spherical Harmonic (Zonal Pattern)\",\n        color=:RdBu)\n\ndestroy_config(cfg)","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Key concepts learned:","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"How to create pure spherical harmonic patterns\nUnderstanding zonal (m=0) vs sectoral (m≠0) modes\nThe relationship between (l,m) indices and spatial patterns\nBasic visualization of spherical data","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Try this: Change (2,0) to (2,2) to see a sectoral pattern!","category":"page"},{"location":"examples/#Example-3:-Understanding-Power-Spectra","page":"Examples Gallery","title":"Example 3: Understanding Power Spectra","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Goal: Learn how energy is distributed across different spatial scales","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\nusing Plots\n\ncfg = create_gauss_config(32, 32)\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n\n# Create a field with multiple scales (like weather patterns)\nfield = @. (2*sin(2*θ)*cos(φ) +        # Large scale (continental)\n           0.5*sin(6*θ)*cos(3*φ) +     # Medium scale (regional)  \n           0.1*sin(12*θ)*cos(6*φ))     # Small scale (local)\n\nprintln(\"Created multi-scale field with 3 different spatial scales\")\n\n# Transform to spectral domain\ncoeffs = analyze(cfg, field)\n\n# Compute power spectrum (energy at each degree l)\npower = power_spectrum(cfg, coeffs)\n\n# Find which scales dominate\nmax_power_degree = argmax(power[2:end])  # Skip l=0 (global mean)\nprintln(\"Peak energy at degree l = $max_power_degree\")\nprintln(\"This corresponds to ~$(360/max_power_degree)° wavelength\")\n\n# Plot the power spectrum\nplot(0:length(power)-1, power, \n     xlabel=\"Spherical Harmonic Degree l\", \n     ylabel=\"Power\",\n     title=\"Energy vs Spatial Scale\",\n     linewidth=2, marker=:circle)\nplot!(yscale=:log10)  # Log scale often reveals more details\n\ndestroy_config(cfg)","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Key concepts learned:","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"How to create multi-scale patterns\nPower spectrum analysis shows energy distribution\nRelationship between degree l and spatial wavelength\nUsing log scales for visualization","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Physical meaning: In meteorology, this tells you whether your weather system is dominated by large-scale patterns (like jet streams) or small-scale features (like thunderstorms).","category":"page"},{"location":"examples/#Intermediate-Examples","page":"Examples Gallery","title":"Intermediate Examples","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Ready to tackle more complex problems? These examples introduce vector fields, real-world data patterns, and scientific applications.","category":"page"},{"location":"examples/#Vector-Field-Decomposition","page":"Examples Gallery","title":"Vector Field Decomposition","text":"","category":"section"},{"location":"examples/#Vorticity-Divergence-Decomposition","page":"Examples Gallery","title":"Vorticity-Divergence Decomposition","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\n\ncfg = create_gauss_config(64, 64)\n\n# Create a realistic atmospheric flow pattern\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\nnlat, nphi = size(θ)\n\n# Jet stream pattern with vortices\nu = @. 20 * sin(2θ) * (1 + 0.4 * cos(4φ))  # Zonal wind\nv = @. 5 * cos(3θ) * sin(2φ)                # Meridional wind\n\nS_lm, T_lm = analyze_vector(cfg, u, v)\n\n# Spatial divergence and vorticity\ndivergence = SHTnsKit.spatial_divergence(cfg, u, v)\nvorticity  = SHTnsKit.spatial_vorticity(cfg, u, v)\n\nprintln(\"Max vorticity: \", maximum(abs.(vorticity)))\nprintln(\"Max divergence: \", maximum(abs.(divergence)))\n\n# Reconstruct original velocity\nu_recon, v_recon = synthesize_vector(cfg, S_lm, T_lm)\nvelocity_error = norm(u - u_recon) + norm(v - v_recon)\nprintln(\"Velocity reconstruction error: $velocity_error\")\n\ndestroy_config(cfg)","category":"page"},{"location":"examples/#Stream-Function-from-Vorticity","page":"Examples Gallery","title":"Stream Function from Vorticity","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\nusing LinearAlgebra\n\ncfg = create_gauss_config(48, 48)\n\n# Create vorticity field (e.g., from observations)\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\nvorticity = @. exp(-((θ - π/2)^2 + (φ - π)^2) / 0.5^2) * sin(4φ)\n\n# Transform vorticity to spectral domain\nζ_lm = analyze(cfg, vorticity)\n\n# Solve ∇²ψ = ζ for stream function ψ\n# In spectral domain: -l(l+1) ψ_lm = ζ_lm\nψ_lm = similar(ζ_lm)\nfor i in 1:get_nlm(cfg)\n    l, m = lm_from_index(cfg, i)\n    if l > 0\n        ψ_lm[i] = -ζ_lm[i] / (l * (l + 1))\n    else\n        ψ_lm[i] = 0.0  # l=0 mode: constant not uniquely determined\n    end\nend\n\nu_stream, v_stream = synthesize_vector(cfg, zero(ψ_lm), ψ_lm)\n\n# Convert stream function to spatial domain\nstream_function = synthesize(cfg, ψ_lm)\n\nprintln(\"Stream function range: \", extrema(stream_function))\nprintln(\"Max velocity from stream: \", maximum(sqrt.(u_stream.^2 + v_stream.^2)))\n\ndestroy_config(cfg)","category":"page"},{"location":"examples/#Geophysics-Applications","page":"Examples Gallery","title":"Geophysics Applications","text":"","category":"section"},{"location":"examples/#Gravitational-Potential-Analysis","page":"Examples Gallery","title":"Gravitational Potential Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\n\ncfg = create_gauss_config(72, 72)  # High resolution for Earth\n\n# Simulate Earth's gravitational field coefficients\n# (In practice, these would come from satellite measurements)\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n\n# Create realistic gravity anomalies\n# J₂ (Earth's oblate shape) + smaller harmonics\ngravity_field = @. -9.81 * (1 + 0.001082 * (1.5 * cos(θ)^2 - 0.5) + \n                           0.0001 * sin(3θ) * cos(2φ))\n\n# Analyze gravity field\ng_lm = analyze(cfg, gravity_field)\n\n# Extract major components\nJ2_coeff = g_lm[lmidx(cfg, 2, 0)]  # J₂ term\nprintln(\"J₂ coefficient: $J2_coeff\")\n\n# Compute power spectrum\npower = power_spectrum(cfg, g_lm)\n\n# Plot power vs degree\nusing Plots\nplot(0:length(power)-1, log10.(power), \n     xlabel=\"Spherical Harmonic Degree l\", \n     ylabel=\"log₁₀(Power)\",\n     title=\"Gravity Field Power Spectrum\")\n\ndestroy_config(cfg)","category":"page"},{"location":"examples/#Magnetic-Field-Modeling","page":"Examples Gallery","title":"Magnetic Field Modeling","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\n\ncfg = create_gauss_config(48, 48)\n\n# Simulate magnetic field measurements (3 components)\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n\n# Dipole + quadrupole + small-scale fields\nBr = @. 30000 * cos(θ) * (1 + 0.1 * cos(2θ) * sin(φ))  # Radial\nBθ = @. 15000 * sin(θ) * (1 - 0.05 * sin(3φ))          # Colatitude  \nBφ = @. 5000 * sin(θ) * cos(θ) * cos(2φ)                # Azimuthal\n\n# Magnetic field is potential: B = -∇V\n# So horizontal components relate to potential derivatives\n# This is a simplified analysis - real magnetic modeling is more complex\n\n# Analyze radial component (related to potential)\nV_lm = analyze(cfg, -Br / 30000)  # Normalized\n\n# Compute horizontal components from potential (spheroidal only)\nBθ_computed, Bφ_computed = synthesize_vector(cfg, V_lm, zeros(V_lm))\n\n# Compare with input\nθ_error = norm(Bθ/15000 - Bθ_computed) / norm(Bθ/15000)\nφ_error = norm(Bφ/5000 - Bφ_computed) / norm(Bφ/5000)\n\nprintln(\"Magnetic field modeling errors:\")\nprintln(\"θ component: $θ_error\")  \nprintln(\"φ component: $φ_error\")\n\ndestroy_config(cfg)","category":"page"},{"location":"examples/#Climate-Science-Applications","page":"Examples Gallery","title":"Climate Science Applications","text":"","category":"section"},{"location":"examples/#Temperature-Anomaly-Analysis","page":"Examples Gallery","title":"Temperature Anomaly Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\nusing Statistics\n\ncfg = create_gauss_config(64, 64)\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n\n# Simulate monthly temperature anomalies\nn_months = 120  # 10 years\nanomalies = []\n\nfor month in 1:n_months\n    # Seasonal cycle + trend + random variations\n    seasonal = @. 5 * cos(2π * month / 12) * cos(θ)\n    trend = @. 0.01 * month * ones(size(θ))\n    random = @. 2 * randn(size(θ)...) * exp(-3 * (θ - π/2)^2)\n    \n    temp_anomaly = seasonal + trend + random\n    push!(anomalies, temp_anomaly)\nend\n\n# Analyze each month\nmonthly_spectra = []\nfor anomaly in anomalies\n    T_lm = analyze(cfg, anomaly)\n    push!(monthly_spectra, T_lm)\nend\n\n# Compute time-averaged power spectrum\navg_power = mean([power_spectrum(cfg, spectrum) for spectrum in monthly_spectra])\n\n# Find dominant modes\nmax_power_idx = argmax(avg_power[2:end]) + 1  # Skip l=0\nprintln(\"Dominant mode: l = $(max_power_idx-1)\")\nprintln(\"Power: $(avg_power[max_power_idx])\")\n\n# Trend analysis - extract l=0,m=0 component (global mean)\nglobal_means = [spectrum[1] for spectrum in monthly_spectra]\nusing Plots\nplot(1:n_months, global_means, \n     xlabel=\"Month\", ylabel=\"Global Mean Anomaly\",\n     title=\"Global Temperature Trend\")\n\ndestroy_config(cfg)","category":"page"},{"location":"examples/#Precipitation-Pattern-Analysis","page":"Examples Gallery","title":"Precipitation Pattern Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\n\ncfg = create_gauss_config(32, 32)\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n\n# Seasonal precipitation patterns\n# Summer: ITCZ near equator, winter: shifted south\nprecip_summer = @. max(0, 10 * exp(-5 * (θ - π/2)^2) * \n                      (1 + 0.3 * cos(2φ)))\nprecip_winter = @. max(0, 8 * exp(-5 * (θ - π/2 - 0.2)^2) * \n                      (1 + 0.2 * cos(3φ)))\n\n# Transform to spectral domain\nP_summer_lm = analyze(cfg, precip_summer)\nP_winter_lm = analyze(cfg, precip_winter)\n\n# Compute seasonal difference\nseasonal_diff_lm = P_summer_lm - P_winter_lm\nseasonal_diff = synthesize(cfg, seasonal_diff_lm)\n\n# Power spectrum of seasonal difference\ndiff_power = power_spectrum(cfg, seasonal_diff_lm)\n\nprintln(\"Seasonal precipitation analysis:\")\nprintln(\"Summer total: \", sum(precip_summer))\nprintln(\"Winter total: \", sum(precip_winter))\nprintln(\"Max seasonal difference: \", maximum(abs.(seasonal_diff)))\n\n# Find regions of maximum seasonal variation\nmax_diff_locations = findall(abs.(seasonal_diff) .> 0.8 * maximum(abs.(seasonal_diff)))\nprintln(\"High variability regions: $(length(max_diff_locations)) grid points\")\n\ndestroy_config(cfg)","category":"page"},{"location":"examples/#Parallel-Computing-Examples","page":"Examples Gallery","title":"Parallel Computing Examples","text":"","category":"section"},{"location":"examples/#MPI-Distributed-Computing","page":"Examples Gallery","title":"MPI Distributed Computing","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Goal: Learn how to use MPI for large-scale parallel spherical harmonic computations","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"# Save as parallel_example.jl and run with: mpiexec -n 4 julia parallel_example.jl\nusing SHTnsKit, MPI, PencilArrays, PencilFFTs\n\nMPI.Init()\n\ncomm = COMM_WORLD\nrank = Comm_rank(comm)\nsize = Comm_size(comm)\n\nif rank == 0\n    println(\"Running SHTnsKit parallel example with $size processes\")\nend\n\n# Create configuration (same on all processes)\ncfg = create_gauss_config(30, 24; mres=64, nlon=96)\npcfg = create_parallel_config(cfg, comm)\n\nif rank == 0\n    println(\"Problem size: $(cfg.nlm) spectral coefficients\")\n    println(\"Grid: $(cfg.nlat) × $(cfg.nphi) spatial points\")\nend\n\n# Create test data\nsh_coeffs = randn(Complex{Float64}, cfg.nlm)\nresult = similar(sh_coeffs)\n\n# Benchmark parallel Laplacian operator\nBarrier(comm)  # Synchronize timing\nstart_time = Wtime()\n\nfor i in 1:50\n    apply_laplacian!(cfg, sh_coeffs)  # Using standard matrix operators\nend\n\nBarrier(comm)\nend_time = Wtime()\n\nif rank == 0\n    avg_time = (end_time - start_time) / 50\n    println(\"Parallel Laplacian: $(avg_time*1000) ms per operation\")\n    \n    # Compare with performance model\n    perf_model = parallel_performance_model(cfg, size)\n    println(\"Expected speedup: $(perf_model.speedup)x\")\n    println(\"Parallel efficiency: $(perf_model.efficiency*100)%\")\nend\n\n# Test parallel transforms\nspatial_data = allocate_spatial(cfg)\nmemory_efficient_parallel_transform!(pcfg, :synthesis, sh_coeffs, spatial_data)\n\nif rank == 0\n    println(\"Parallel synthesis completed\")\nend\n\n# Test communication-intensive operator (cos θ)\napply_costheta_operator!(cfg, sh_coeffs, result)  # Using standard matrix operators\n\nif rank == 0\n    println(\"Parallel cos(θ) operator completed\")\nend\n\nMPI.Finalize()","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Key concepts:","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"MPI initialization and communicator setup\nCreating parallel configurations with domain decomposition\nUsing parallel operators for distributed computation\nPerformance timing and comparison with models","category":"page"},{"location":"examples/#Run-Example-Scripts","page":"Examples Gallery","title":"Run Example Scripts","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"# Per-rank SHT scalar roundtrip (safe PencilArrays allocation)\nmpiexec -n 2 julia --project=. examples/parallel_roundtrip.jl\n\n# Distributed FFT roundtrip along φ using PencilFFTs\nmpiexec -n 2 julia --project=. examples/parallel_fft_roundtrip.jl","category":"page"},{"location":"examples/#SIMD-Vectorization-Example","page":"Examples Gallery","title":"SIMD Vectorization Example","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Goal: Leverage advanced SIMD optimizations for single-node performance","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit, LoopVectorization, BenchmarkTools\n\ncfg = create_gauss_config(64, 64)\nsh_coeffs = randn(Complex{Float64}, cfg.nlm)\n\nprintln(\"SIMD Optimization Comparison\")\nprintln(\"=\"^40)\n\n# Benchmark regular SIMD\nregular_time = @belapsed apply_laplacian!($cfg, copy($sh_coeffs))\nprintln(\"Regular SIMD: $(regular_time*1000) ms\")\n\n# Same function for comparison (all optimizations are built-in)\noptimized_time = @belapsed apply_laplacian!($cfg, copy($sh_coeffs))\nprintln(\"Optimized:    $(optimized_time*1000) ms\")\n\n# Since we're using the same function, speedup will be ~1.0\nspeedup = regular_time / optimized_time\nprintln(\"Implementation speedup: $(speedup)x\")\n\n# Both results are identical (same function)\nresult1 = copy(sh_coeffs)\nresult2 = copy(sh_coeffs)\n\napply_laplacian!(cfg, result1)\napply_laplacian!(cfg, result2)\n\nmax_diff = maximum(abs.(result1 - result2))\nprintln(\"Max difference: $max_diff (should be ~0)\")\n\n# Benchmark comprehensive comparison\nresults = benchmark_turbo_vs_simd(cfg)\nprintln(\"\\nDetailed Benchmark Results:\")\nprintln(\"  SIMD time: $(results.simd_time*1000) ms\")\nprintln(\"  Turbo time: $(results.turbo_time*1000) ms\") \nprintln(\"  Speedup: $(results.speedup)x\")\nprintln(\"  Accuracy: max diff = $(results.max_difference)\")\n\ndestroy_config(cfg)","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Key concepts:","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"LoopVectorization.jl integration for enhanced SIMD\nPerformance benchmarking and verification\nAutomatic optimization selection","category":"page"},{"location":"examples/#Hybrid-MPI-SIMD-Example","page":"Examples Gallery","title":"Hybrid MPI + SIMD Example","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Goal: Combine distributed and SIMD parallelization for maximum performance","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"# Save as hybrid_example.jl, run with: mpiexec -n 4 julia hybrid_example.jl\nusing SHTnsKit, MPI, PencilArrays, PencilFFTs, LoopVectorization\n\nMPI.Init()\n\ncomm = COMM_WORLD\nrank = Comm_rank(comm)\nsize = Comm_size(comm)\n\n# Large problem that benefits from both MPI and SIMD\ncfg = create_gauss_config(128, 128; mres=256, nlon=512)\npcfg = create_parallel_config(cfg, comm)\n\nif rank == 0\n    println(\"Hybrid MPI + SIMD Example\")\n    println(\"Problem: $(cfg.nlm) coefficients, $(cfg.nlat)×$(cfg.nphi) grid\")\n    println(\"MPI processes: $size\")\n    println(\"SIMD: LoopVectorization enabled\")\nend\n\n# Test data\nsh_coeffs = randn(Complex{Float64}, cfg.nlm)\nresult = similar(sh_coeffs)\n\n# Benchmark different approaches\ntests = [\n    (\"Parallel standard\", () -> apply_laplacian!(cfg, sh_coeffs)  # Using standard matrix operators),\n    (\"Parallel + turbo\", () -> begin\n        # This would use turbo optimizations within parallel operations\n        apply_laplacian!(cfg, sh_coeffs)  # Using standard matrix operators\n    end)\n]\n\nif rank == 0\n    println(\"\\nPerformance Comparison:\")\nend\n\nfor (name, test_func) in tests\n    Barrier(comm)\n    start_time = Wtime()\n    \n    for i in 1:20\n        test_func()\n    end\n    \n    Barrier(comm)\n    end_time = Wtime()\n    \n    if rank == 0\n        avg_time = (end_time - start_time) / 20\n        println(\"$name: $(avg_time*1000) ms per operation\")\n    end\nend\n\n# Test scaling efficiency\nif rank == 0\n    println(\"\\nScaling Analysis:\")\n    for test_size in [2, 4, 8, 16]\n        if test_size <= size * 2  # Don't test more than 2x current size\n            model = parallel_performance_model(cfg, test_size)\n            println(\"$test_size processes: $(model.speedup)x speedup, $(model.efficiency*100)% efficiency\")\n        end\n    end\nend\n\nMPI.Finalize()","category":"page"},{"location":"examples/#Asynchronous-Parallel-Operations","page":"Examples Gallery","title":"Asynchronous Parallel Operations","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Goal: Use non-blocking communication for better performance overlap","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit, MPI, PencilArrays, PencilFFTs\n\nMPI.Init()\n\ncomm = COMM_WORLD\nrank = Comm_rank(comm)\nsize = Comm_size(comm)\n\ncfg = create_gauss_config(64, 48; mres=128, nlon=192)\npcfg = create_parallel_config(cfg, comm)\n\nif rank == 0\n    println(\"Asynchronous Parallel Operations Example\")\nend\n\nsh_coeffs = randn(Complex{Float64}, cfg.nlm)\nresult = similar(sh_coeffs)\n\n# Compare synchronous vs asynchronous operations\nif rank == 0\n    println(\"Benchmarking communication patterns...\")\nend\n\n# Synchronous (blocking)\nBarrier(comm)\nsync_time = @elapsed begin\n    for i in 1:30\n        apply_costheta_operator!(cfg, sh_coeffs, result)  # Using standard matrix operators\n    end\nend\n\n# Asynchronous (non-blocking, if available)\nBarrier(comm)\nasync_time = @elapsed begin\n    for i in 1:30\n        try\n            # Try asynchronous version\n            apply_costheta_operator!(cfg, sh_coeffs, result)  # Standard implementation\n        catch\n            # Fall back to synchronous if not available\n            apply_costheta_operator!(cfg, sh_coeffs, result)  # Using standard matrix operators\n        end\n    end\nend\n\nif rank == 0\n    println(\"Communication Performance:\")\n    println(\"  Synchronous:  $(sync_time/30*1000) ms per operation\")\n    println(\"  Asynchronous: $(async_time/30*1000) ms per operation\")\n    if async_time < sync_time\n        println(\"  Async speedup: $(sync_time/async_time)x\")\n    else\n        println(\"  No async improvement (likely using fallback)\")\n    end\nend\n\nMPI.Finalize()","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Key concepts:","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"Non-blocking MPI communication patterns\nCommunication-computation overlap\nPerformance analysis of different parallel strategies","category":"page"},{"location":"examples/#Advanced-Applications","page":"Examples Gallery","title":"Advanced Applications","text":"","category":"section"},{"location":"examples/#Multiscale-Analysis","page":"Examples Gallery","title":"Multiscale Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\n\n# Create different resolution configurations\ncfgs = [create_gauss_config(l, l) for l in [16, 32, 64, 128]]\n\n# Create test field with multiple scales\nθ, φ = SHTnsKit.create_coordinate_matrices(cfgs[end])  # Use highest resolution grid\nfield = @. (sin(2θ) * cos(φ) +           # Large scale\n           0.3 * sin(8θ) * cos(4φ) +     # Medium scale\n           0.1 * sin(16θ) * cos(8φ))     # Small scale\n\n# Analyze at different resolutions\npowers = []\nfor (i, cfg) in enumerate(cfgs)\n    # Interpolate field to current grid if needed\n    θ_i, φ_i = SHTnsKit.create_coordinate_matrices(cfg)\n    field_i = field[1:get_nlat(cfg), 1:get_nphi(cfg)]  # Simple subsampling\n    \n    # Analyze and compute power spectrum\n    f_lm = analyze(cfg, field_i)\n    power_i = power_spectrum(cfg, f_lm)\n    push!(powers, power_i)\n    \n    println(\"Resolution $(get_lmax(cfg)): $(length(power_i)) modes\")\nend\n\n# Compare power spectra\nusing Plots\np = plot(xlabel=\"Spherical Harmonic Degree\", ylabel=\"Power\", yscale=:log10)\nfor (i, power) in enumerate(powers)\n    plot!(p, 0:length(power)-1, power, \n          label=\"lmax = $(get_lmax(cfgs[i]))\", linewidth=2)\nend\ndisplay(p)\n\n# Cleanup\nfor cfg in cfgs\n    destroy_config(cfg)\nend","category":"page"},{"location":"examples/#Field-Rotation-and-Coordinate-Transformations","page":"Examples Gallery","title":"Field Rotation and Coordinate Transformations","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\n\ncfg = create_gauss_config(32, 32)\n\n# Create field in one coordinate system\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\noriginal_field = @. sin(3θ) * cos(2φ)\n\n# Rotate coordinates (simulate different observation viewpoint)\nα, β, γ = π/4, π/6, π/8  # Euler angles\n\nf_lm = analyze(cfg, original_field)\nf_rot = copy(f_lm)\nrotate_real!(cfg, f_rot; alpha=α, beta=β, gamma=γ)\nrotated_field = synthesize(cfg, f_rot)\n\ndestroy_config(cfg)","category":"page"},{"location":"examples/#High-Performance-Examples","page":"Examples Gallery","title":"High-Performance Examples","text":"","category":"section"},{"location":"examples/#Multi-threaded-Batch-Processing","page":"Examples Gallery","title":"Multi-threaded Batch Processing","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\nusing Base.Threads\n\ncfg = create_gauss_config(64, 64)\nset_optimal_threads!()\n\n# Large batch of fields to process\nn_batch = 1000\ninput_fields = [rand(get_nlat(cfg), get_nphi(cfg)) for _ in 1:n_batch]\n\n# Process with threading\nprintln(\"Processing $n_batch fields with $(nthreads()) Julia threads...\")\nresults = Vector{Float64}(undef, n_batch)\n\n@time @threads for i in 1:n_batch\n    # Each thread gets its own work\n    field = input_fields[i]\n    \n    # Transform and compute some property\n    sh = analyze(cfg, field)\n    power = power_spectrum(cfg, sh)\n    \n    # Store result\n    results[i] = sum(power)  # Total energy\nend\n\nprintln(\"Mean energy per field: \", mean(results))\nprintln(\"Energy std dev: \", std(results))\n\ndestroy_config(cfg)","category":"page"},{"location":"examples/#Validation-and-Testing-Examples","page":"Examples Gallery","title":"Validation and Testing Examples","text":"","category":"section"},{"location":"examples/#Analytical-Test-Cases","page":"Examples Gallery","title":"Analytical Test Cases","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\n\ncfg = create_gauss_config(24, 24)\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n\n# Test Case 1: Pure spherical harmonics\ntest_cases = [\n    (l=0, m=0, Y=(θ,φ) -> 1/sqrt(4π)),\n    (l=1, m=-1, Y=(θ,φ) -> sqrt(3/(8π)) * sin.(θ) .* sin.(φ)),  \n    (l=1, m=0, Y=(θ,φ) -> sqrt(3/(4π)) * cos.(θ)),\n    (l=1, m=1, Y=(θ,φ) -> -sqrt(3/(8π)) * sin.(θ) .* cos.(φ)),\n    (l=2, m=0, Y=(θ,φ) -> sqrt(5/(16π)) * (3*cos.(θ).^2 .- 1))\n]\n\nprintln(\"Analytical validation tests:\")\nfor (i, case) in enumerate(test_cases)\n    # Create analytical field\n    Y_analytical = case.Y(θ, φ)\n    \n    # Transform to spectral\n    sh = analyze(cfg, Y_analytical)\n    \n    # Check that only the correct coefficient is non-zero\nexpected_idx = lmidx(cfg, case.l, case.m)\n    \n    # Find largest coefficient\n    max_idx = argmax(abs.(sh))\n    max_val = sh[max_idx]\n    \n    println(\"Test $i: l=$(case.l), m=$(case.m)\")\n    println(\"  Expected index: $expected_idx, Found: $max_idx\")\n    println(\"  Coefficient value: $max_val\")\n    \n    if max_idx == expected_idx\n        println(\"   PASS\")\n    else\n        println(\"  FAIL\")\n    end\nend\n\ndestroy_config(cfg)","category":"page"},{"location":"examples/#Numerical-Accuracy-Tests","page":"Examples Gallery","title":"Numerical Accuracy Tests","text":"","category":"section"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"using SHTnsKit\n\n# Test different resolutions and grid types\nresolutions = [16, 32, 64]\ngrid_types = [:gauss, :regular]\n\nprintln(\"Accuracy vs Resolution Test:\")\nfor grid_type in grid_types\n    println(\"\\n$grid_type Grid:\")\n    \n    for lmax in resolutions\n        cfg = grid_type == :gauss ? \n              create_gauss_config(lmax, lmax) : \n              create_regular_config(lmax, lmax)\n        \n        # Random test field\n        sh_original = rand(get_nlm(cfg))\n        \n        # Round-trip transform\n        spatial = synthesize(cfg, sh_original)\n        sh_recovered = analyze(cfg, spatial)\n        \n        # Measure error\n        error = norm(sh_original - sh_recovered) / norm(sh_original)\n        \n        println(\"  lmax=$lmax: error = $error\")\n        \n        destroy_config(cfg)\n    end\nend","category":"page"},{"location":"examples/","page":"Examples Gallery","title":"Examples Gallery","text":"These examples demonstrate the full range of SHTnsKit.jl capabilities from basic transforms to advanced scientific applications. Each example can serve as a starting point for your specific research needs.","category":"page"},{"location":"mpi_roundtrip/#Distributed-Round-trip-Example-(MPI)","page":"-","title":"Distributed Round-trip Example (MPI)","text":"","category":"section"},{"location":"mpi_roundtrip/","page":"-","title":"-","text":"This sketch shows how to run a distributed scalar round-trip using PencilArrays and PencilFFTs. It assumes you have constructed a (θ,φ) prototype PencilArray on your MPI communicator.","category":"page"},{"location":"mpi_roundtrip/","page":"-","title":"-","text":"using MPI, PencilArrays, PencilFFTs, SHTnsKit\n\nMPI.Init()\ncomm = COMM_WORLD\n\n# Build config and prototype (θ,φ) pencil\ncfg = create_gauss_config(32, 40; nlon=65)\n\n# Assume you created a prototype `(θ,φ)` pencil named proto_θφ.\n# For example (API depends on your PencilArrays version):\n# proto_θφ = allocate(comm; dims=(:θ,:φ), sizes=(cfg.nlat, cfg.nlon), eltype=Float64)\n\n# Fill a test field\nfθφ = similar(proto_θφ)\nforeachindex(fθφ) do I\n    fθφ[I] = rand()\nend\n\n# Distributed analysis -> Alm (dense for now)\nAlm = dist_analysis(cfg, fθφ)\n\n# Distributed synthesis using prototype\nfθφ_out = dist_synthesis(cfg, Alm; prototype_θφ=fθφ)\n\n# Compute local/global relative errors\nrel_local, rel_global = dist_scalar_roundtrip!(cfg, fθφ)\nif Comm_rank(comm) == 0\n    @info \"Scalar round-trip rel error\" rel_local rel_global\nend\n\nMPI.Finalize()","category":"page"},{"location":"mpi_roundtrip/","page":"-","title":"-","text":"For vector fields, use dist_spat_to_SHsphtor and dist_SHsphtor_to_spat with the same prototype_θφ. Precomputing Legendre tables via prepare_plm_tables!(cfg) on regular grids typically improves performance.","category":"page"},{"location":"distributed/#Distributed-SHTnsKit-Guide-(MPI-PencilArrays)","page":"Distributed Guide","title":"Distributed SHTnsKit Guide (MPI + PencilArrays)","text":"","category":"section"},{"location":"distributed/","page":"Distributed Guide","title":"Distributed Guide","text":"<div align=\"right\"><em>This page is mirrored from docs/Distributed_SHTnsKit_Guide.md</em></div>","category":"page"},{"location":"distributed/","page":"Distributed Guide","title":"Distributed Guide","text":"Depth = 2","category":"page"},{"location":"distributed/","page":"Distributed Guide","title":"Distributed Guide","text":"```@raw\n$(read(joinpath(@__DIR__, \"..\", \"Distributed_SHTnsKit_Guide.md\"), String))\n```","category":"page"},{"location":"quickstart/#Quick-Start-Guide","page":"Quick Start","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"This tutorial will get you up and running with SHTnsKit.jl for spherical harmonic transforms in just a few minutes.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"What you'll learn:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Basic concepts: spectral vs spatial domains\nHow to perform your first transform\nWorking with real geophysical data\nVector field analysis\nPerformance optimization","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Prerequisites: Basic Julia knowledge and familiarity with arrays and functions.","category":"page"},{"location":"quickstart/#Your-First-Transform","page":"Quick Start","title":"Your First Transform","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Let's start with a simple example to understand the basic workflow:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using SHTnsKit\n\n# Step 1: Create a spherical harmonic configuration\nlmax = 32        # Maximum degree (controls resolution)\nmmax = 32        # Maximum order (typically same as lmax)\ncfg = create_gauss_config(lmax, mmax)\n\n# Step 2: Generate some random spectral coefficients\n# These represent the \"recipe\" for building a function on the sphere\nsh_coeffs = rand(get_nlm(cfg))\nprintln(\"Number of coefficients: \", length(sh_coeffs))\n\n# Step 3: Transform from spectral to spatial domain (synthesis)\n# This builds the actual function values on a grid\nspatial_field = synthesize(cfg, sh_coeffs)\nprintln(\"Spatial field size: \", size(spatial_field))\n\n# Step 4: Transform back to spectral domain (analysis)\n# This recovers the coefficients from the spatial data\nrecovered_coeffs = analyze(cfg, spatial_field)\n\n# Step 5: Check accuracy (should be very small)\nerror = norm(sh_coeffs - recovered_coeffs)\nprintln(\"Round-trip error: $error\")\n\n# Step 6: Always clean up\ndestroy_config(cfg)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"What just happened?","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Configuration: We set up the transform parameters (resolution and grid type)\nCoefficients: Created random spherical harmonic coefficients \nSynthesis: Converted coefficients → spatial values (spectral to physical)\nAnalysis: Converted spatial values → coefficients (physical to spectral)\nVerification: The tiny error confirms the transforms are working correctly","category":"page"},{"location":"quickstart/#Understanding-the-Basics","page":"Quick Start","title":"Understanding the Basics","text":"","category":"section"},{"location":"quickstart/#Spectral-vs-Spatial-Domains","page":"Quick Start","title":"Spectral vs Spatial Domains","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Understanding the two ways to represent data is key to using spherical harmonics effectively:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Spatial Domain: Values at specific points on the sphere\nLike having temperature measurements at weather stations\n2D array: field[latitude, longitude]\nEasy to visualize and interpret physically\nSpectral Domain: Coefficients of mathematical basis functions (spherical harmonics)\nLike having the \"recipe\" ingredients for recreating the field\n1D array: coeffs[mode_index]\nCompact representation, efficient for analysis","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Analogy: Think of a recipe vs a finished dish","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Spatial = the finished dish (what you see/taste)\nSpectral = the recipe (ingredients that make the dish)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"cfg = create_gauss_config(16, 16)\n\n# Spectral domain: 1D array of coefficients\nnlm = get_nlm(cfg)        # Number of (l,m) coefficients  \nsh = zeros(nlm)           # Initialize spectral coefficients\nsh[1] = 1.0               # Set Y_0^0 = constant field (global average)\nprintln(\"Spectral domain: \", length(sh), \" coefficients\")\n\n# Spatial domain: 2D array of values on sphere\nnlat, nphi = get_nlat(cfg), get_nphi(cfg)\nprintln(\"Spatial domain: $nlat × $nphi = $(nlat*nphi) grid points\")\n\n# Transform: spectral → spatial (synthesis)\nspatial = synthesize(cfg, sh)\nprintln(\"Result: all values should be the same (constant field)\")\nprintln(\"Min/max values: \", extrema(spatial))\n\ndestroy_config(cfg)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Key insight: Setting only the first coefficient (sh[1]) creates a perfectly constant field over the entire sphere, demonstrating how spherical harmonics work as building blocks.","category":"page"},{"location":"quickstart/#Grid-Types","page":"Quick Start","title":"Grid Types","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"SHTnsKit supports different ways to arrange points on the sphere. Think of it like choosing between different types of graph paper:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"# Gauss-Legendre grid (optimal for spectral accuracy)\ncfg_gauss = create_gauss_config(32, 32)\nprintln(\"Gauss grid: $(get_nlat(cfg_gauss)) × $(get_nphi(cfg_gauss))\")\n\n# Regular equiangular grid  \ncfg_regular = create_regular_config(32, 32)\nprintln(\"Regular grid: $(get_nlat(cfg_regular)) × $(get_nphi(cfg_regular))\")\n\ndestroy_config(cfg_gauss)\ndestroy_config(cfg_regular)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Which grid should you use?","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Gauss-Legendre grid (create_gauss_config):\nBest for: Most scientific applications\nPros: Optimal mathematical properties, highest accuracy\nCons: Uneven spacing (denser near poles)\nUse when: You want the best accuracy and don't need uniform spacing\nRegular grid (create_regular_config):\nBest for: Visualization, interfacing with other software  \nPros: Uniform spacing, easier to understand\nCons: Slightly less accurate\nUse when: You need uniform spacing or are working with external data","category":"page"},{"location":"quickstart/#Working-with-Real-Data","page":"Quick Start","title":"Working with Real Data","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Now let's move beyond random numbers and work with realistic geophysical data patterns.","category":"page"},{"location":"quickstart/#Creating-Realistic-Test-Fields","page":"Quick Start","title":"Creating Realistic Test Fields","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"cfg = create_gauss_config(24, 24)\n\n# Get grid coordinate matrices\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\nprintln(\"Grid coordinates:\")\nprintln(\"  θ (colatitude): 0 to π (north pole to south pole)\")\nprintln(\"  φ (longitude): 0 to 2π (around the equator)\")\n\n# Create a realistic temperature pattern\n# Cold at poles, warm at equator, with some longitude variation\nbase_temp = 273.15  # 0°C in Kelvin\nequatorial_warming = 30  # 30K warmer at equator\nlongitude_variation = 5   # 5K variation with longitude\n\ntemperature = @. base_temp + equatorial_warming * sin(θ)^2 + \n                 longitude_variation * cos(3*φ) * sin(θ)\n\nprintln(\"Temperature field stats:\")\nprintln(\"  Min: $(minimum(temperature)) K ($(minimum(temperature)-273.15)°C)\")\nprintln(\"  Max: $(maximum(temperature)) K ($(maximum(temperature)-273.15)°C)\")\n\n# Analyze to get spectral coefficients\ntemp_coeffs = analyze(cfg, temperature)\n\n# Find the most important modes\ncoeffs_magnitude = abs.(temp_coeffs)\nsorted_indices = sortperm(coeffs_magnitude, rev=true)\n\nprintln(\"\\nTop 5 most important modes:\")\nfor i in 1:5\n    idx = sorted_indices[i]\n    l, m = SHTnsKit.lm_from_index(cfg, idx)\n    println(\"  Mode $i: l=$l, m=$m, magnitude=$(coeffs_magnitude[idx])\")\nend\n\ndestroy_config(cfg)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"What this shows:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"How to create realistic geophysical patterns using trigonometric functions\nThe relationship between spatial patterns and spherical harmonic modes\nHow to identify which modes are most important in your data","category":"page"},{"location":"quickstart/#Physical-Fields","page":"Quick Start","title":"Physical Fields","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"cfg = create_gauss_config(32, 32)\nθ, φ = SHTnsKit.create_coordinate_matrices(cfg)\n\n# Temperature-like field with equatorial maximum\ntemperature = 300 .+ 50 * cos.(2 * θ) .* cos.(φ)\n\n# Transform to spectral domain\ntemp_sh = analyze(cfg, temperature)\n\n# Reconstruct and compare\ntemp_reconstructed = synthesize(cfg, temp_sh)\nreconstruction_error = norm(temperature - temp_reconstructed)\nprintln(\"Temperature reconstruction error: $reconstruction_error\")\n\ndestroy_config(cfg)","category":"page"},{"location":"quickstart/#Vector-Fields","page":"Quick Start","title":"Vector Fields","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Vector fields on the sphere are decomposed into spheroidal and toroidal components:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"cfg = create_gauss_config(20, 20)\n\n# Create random spheroidal and toroidal coefficients\nS_lm = rand(get_nlm(cfg))  # Spheroidal coefficients\nT_lm = rand(get_nlm(cfg))  # Toroidal coefficients\n\n# Synthesize vector field components\nV_theta, V_phi = synthesize_vector(cfg, S_lm, T_lm)\n\nprintln(\"Vector field size: \", size(V_theta), \" and \", size(V_phi))\n\n# Analyze back to get coefficients\nS_recovered, T_recovered = analyze_vector(cfg, V_theta, V_phi)\n\n# Check accuracy\nS_error = norm(S_lm - S_recovered)\nT_error = norm(T_lm - T_recovered)\nprintln(\"Spheroidal error: $S_error, Toroidal error: $T_error\")\n\ndestroy_config(cfg)","category":"page"},{"location":"quickstart/#Gradient-and-Curl","page":"Quick Start","title":"Gradient and Curl","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"cfg = create_gauss_config(20, 20)\n\n# Example: compute spatial derivatives via FFT in φ\nspatial = rand(get_nlat(cfg), get_nphi(cfg))\ndφ = SHTnsKit.spatial_derivative_phi(cfg, spatial)\n\nprintln(\"Spatial derivative field size: \", size(dφ))\n\ndestroy_config(cfg)","category":"page"},{"location":"quickstart/#Complex-Fields","page":"Quick Start","title":"Complex Fields","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"For complex-valued fields (e.g., wave functions):","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"cfg = create_gauss_config(16, 16)\n\n# Create complex spectral coefficients\nsh_complex = rand(ComplexF64, get_nlm(cfg))\n\n# Complex field synthesis\nspatial_complex = synthesize_complex(cfg, sh_complex)\n\n# Complex field analysis\nrecovered_complex = analyze_complex(cfg, spatial_complex)\n\n# Check accuracy\ncomplex_error = norm(sh_complex - recovered_complex)\nprintln(\"Complex field error: $complex_error\")\n\ndestroy_config(cfg)","category":"page"},{"location":"quickstart/#Performance-and-Threading","page":"Quick Start","title":"Performance and Threading","text":"","category":"section"},{"location":"quickstart/#Threading-and-FFTW-threads","page":"Quick Start","title":"Threading and FFTW threads","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"# Enable parallel loops and set FFTW threads sensibly\nsummary = set_optimal_threads!()\nprintln(summary)  # (threads=..., fft_threads=...)\n\n# Fine-tune\nset_threading!(true)           # enable/disable parallel loops\nset_fft_threads(4); get_fft_threads()","category":"page"},{"location":"quickstart/#Benchmarking","page":"Quick Start","title":"Benchmarking","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"cfg = create_gauss_config(64, 64)\nsh = rand(get_nlm(cfg))\n\n# Time forward transform\n@time spatial = synthesize(cfg, sh)\n\n# Time backward transform  \n@time recovered = analyze(cfg, spatial)\n\n# Multiple runs for better statistics\nprintln(\"Forward transform timing:\")\n@time for i in 1:10\n    synthesize(cfg, sh)\nend\n\ndestroy_config(cfg)","category":"page"},{"location":"quickstart/#GPU-Acceleration","page":"Quick Start","title":"GPU Acceleration","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"This package is CPU‑focused and does not include GPU support.","category":"page"},{"location":"quickstart/#Common-Patterns","page":"Quick Start","title":"Common Patterns","text":"","category":"section"},{"location":"quickstart/#In-Place-Operations","page":"Quick Start","title":"In-Place Operations","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"For memory efficiency:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"cfg = create_gauss_config(24, 24)\n\n# Pre-allocate arrays\nsh = allocate_spectral(cfg)\nspatial = allocate_spatial(cfg)\n\n# In-place operations (no additional allocation)\nrand!(sh)\nsynthesize!(cfg, sh, spatial)  # spatial = synthesize(cfg, sh)\nanalyze!(cfg, spatial, sh)     # sh = analyze(cfg, spatial)\n\ndestroy_config(cfg)","category":"page"},{"location":"quickstart/#Batch-Processing","page":"Quick Start","title":"Batch Processing","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"cfg = create_gauss_config(20, 20)\n\n# Process multiple fields\nn_fields = 100\nresults = []\n\nfor i in 1:n_fields\n    # Generate field\n    sh = rand(get_nlm(cfg))\n    \n    # Process\n    spatial = synthesize(cfg, sh)\n    \n    # Store result (example: compute mean)\n    push!(results, mean(spatial))\n    \n    # Progress indicator\n    i % 20 == 0 && println(\"Processed $i/$n_fields fields\")\nend\n\nprintln(\"Mean of field means: \", mean(results))\ndestroy_config(cfg)","category":"page"},{"location":"quickstart/#Error-Handling","page":"Quick Start","title":"Error Handling","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"cfg = create_gauss_config(16, 16)\n\ntry\n    # Wrong array size\n    wrong_sh = rand(10)  # Should be get_nlm(cfg)\n    spatial = synthesize(cfg, wrong_sh)\ncatch e\n    println(\"Caught expected error: \", e)\nend\n\n# Proper size check\nsh = rand(get_nlm(cfg))\n@assert length(sh) == get_nlm(cfg) \"Wrong spectral array size\"\n\nspatial = synthesize(cfg, sh)\nprintln(\"Successful transform with proper size\")\n\ndestroy_config(cfg)","category":"page"},{"location":"quickstart/#Next-Steps","page":"Quick Start","title":"Next Steps","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Now that you've mastered the basics:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Read the API Reference for complete function documentation\nExplore Examples for real-world applications  \nCheck Performance Guide for optimization tips\nSee Advanced Usage for complex workflows","category":"page"},{"location":"quickstart/#Quick-Reference","page":"Quick Start","title":"Quick Reference","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"# Configuration\ncfg = create_gauss_config(lmax, mmax)\ncfg = create_regular_config(lmax, mmax)\n\n# Basic transforms\nspatial = synthesize(cfg, spectral)\nspectral = analyze(cfg, spatial)\n\n# Vector transforms  \nVθ, Vφ = synthesize_vector(cfg, S_lm, T_lm)\nS_lm, T_lm = analyze_vector(cfg, Vθ, Vφ)\n\n# Complex fields\nspatial_c = synthesize_complex(cfg, spectral_c)\nspectral_c = analyze_complex(cfg, spatial_c)\n\n# Threading\nset_threading!(true)\nset_optimal_threads!()\n\n# Cleanup\ndestroy_config(cfg)","category":"page"},{"location":"#SHTnsKit.jl","page":"Home","title":"SHTnsKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"High-performance spherical harmonic transforms for scientific computing","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Documentation) (Image: License: GPL v3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"SHTnsKit.jl is a high-performance native Julia implementation of spherical harmonic transforms (SHT). It provides fast and memory‑efficient scalar, vector, and complex transforms with comprehensive parallel computing support, suitable for fluid dynamics, geophysics, astrophysics, and climate science applications.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"#Core-Transforms","page":"Home","title":"Core Transforms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Scalar Transforms: Forward and backward spherical harmonic transforms\nComplex Field Transforms: Support for complex-valued fields on the sphere  \nVector Transforms: Spheroidal-toroidal decomposition of vector fields\nIn-place Operations: Memory-efficient transform operations","category":"page"},{"location":"#Advanced-Capabilities","page":"Home","title":"Advanced Capabilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multiple Grid Types: Gauss-Legendre and regular (equiangular) grids\nField Rotations: Wigner D-matrix rotations in spectral and spatial domains\nPower Spectrum Analysis: Energy distribution across spherical harmonic modes\nMultipole Analysis: Expansion coefficients for gravitational/magnetic fields","category":"page"},{"location":"#High-Performance-Computing","page":"Home","title":"High-Performance Computing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MPI Parallelization: Distributed spherical harmonic transforms with domain decomposition\nSIMD Optimization: Advanced vectorization with LoopVectorization.jl\nThreading Controls: Julia Threads.@threads loops and FFTW thread tuning\nMemory Management: Efficient allocation and thread‑safe operations\nAutomatic Differentiation: Full support for ForwardDiff.jl and ChainRulesCore.jl","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Serial-Usage","page":"Home","title":"Serial Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using SHTnsKit\n\n# Create spherical harmonic configuration\nlmax = 32\ncfg = create_gauss_config(lmax, lmax)\n\n# Generate test data\nsh_coeffs = rand(get_nlm(cfg))\n\n# Forward transform: spectral → spatial\nspatial_field = synthesize(cfg, sh_coeffs)\n\n# Backward transform: spatial → spectral\nrecovered_coeffs = analyze(cfg, spatial_field)\n\n# Clean up\ndestroy_config(cfg)","category":"page"},{"location":"#Parallel-Usage-(MPI)","page":"Home","title":"Parallel Usage (MPI)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using SHTnsKit, MPI, PencilArrays, PencilFFTs\n\nMPI.Init()\ncfg = create_gauss_config(20, 16; mres=48, nlon=64)\npcfg = create_parallel_config(cfg, COMM_WORLD)\n\n# Parallel operations\nsh_coeffs = randn(Complex{Float64}, cfg.nlm)\nresult = similar(sh_coeffs)\nparallel_apply_operator(pcfg, :laplacian, sh_coeffs, result)\n\nMPI.Finalize()","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#Basic-Installation","page":"Home","title":"Basic Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SHTnsKit\")","category":"page"},{"location":"#With-Parallel-Computing-Support","page":"Home","title":"With Parallel Computing Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add([\"SHTnsKit\", \"MPI\", \"PencilArrays\", \"PencilFFTs\", \"LoopVectorization\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Installation Guide for detailed setup instructions and MPI configuration.","category":"page"},{"location":"#Documentation-Overview","page":"Home","title":"Documentation Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"installation.md\",\n    \"parallel_installation.md\",\n    \"quickstart.md\", \n    \"api/index.md\",\n    \"examples/index.md\",\n    \"performance.md\",\n    \"advanced.md\"\n]\nDepth = 2","category":"page"},{"location":"#Scientific-Applications","page":"Home","title":"Scientific Applications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fluid Dynamics: Vorticity-divergence decomposition, stream function computation\nGeophysics: Gravitational and magnetic field analysis, Earth's surface modeling\nAstrophysics: Cosmic microwave background analysis, stellar surface dynamics\nClimate Science: Atmospheric and oceanic flow patterns, weather prediction\nPlasma Physics: Magnetohydrodynamics simulations, fusion plasma modeling","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SHTnsKit.jl achieves exceptional performance through:","category":"page"},{"location":"","page":"Home","title":"Home","text":"MPI Parallelization: Distributed computing with 2D domain decomposition\nSIMD Vectorization: Advanced optimizations with LoopVectorization.jl\nPure Julia kernels: SIMD‑friendly loops with automatic optimization\nFFTW integration: Parallel FFTs with configurable threading\nMemory efficiency: Minimal allocations and optimized data layouts","category":"page"},{"location":"","page":"Home","title":"Home","text":"Problem Size (nlm) Serial 4 Processes 16 Processes Speedup\n1,000 5ms 4ms 5ms 1.3x\n10,000 50ms 18ms 12ms 4.2x\n100,000 500ms 140ms 65ms 7.7x","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use SHTnsKit.jl in your research, please cite the package (citation info forthcoming).","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SHTnsKit.jl is released under the GNU General Public License v3.0, ensuring compatibility with the underlying SHTns library's CeCILL license.","category":"page"},{"location":"#Support","page":"Home","title":"Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation: Complete API reference and examples\nExamples: Comprehensive example gallery covering all use cases\nIssues: Report bugs and feature requests on GitHub\nDiscussions: Community support and questions","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FFTW.jl - Fast Fourier transforms\nSphericalHarmonics.jl - Alternative pure Julia implementation\nFastTransforms.jl - Various fast transforms","category":"page"}]
}
